---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---

### Libraries
```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(nlme)
library(splines2)
```


### initialization

```{r}


suppressMessages({
  # File pathway linking to the reflectance data for Thraupidae specimens on laptop
  ddPath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\RefDataSpeciesSummary_MatchingMF\\data"
  
  # File pathway linking to the reflectance data for Thraupidae specimens on PC
#  ddPath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\RefDataSpeciesSummary_MatchingMF"

  # Reads in all of .csv files
  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  # Extracts all of the wavelengths and turns it into a vector
  wl <- dat[[1]][, 1]
  # Removes the wavelength column from each of the species' dataframes
  dat <- sapply(dat, "[", -1)
  
  # Takes the reflectance data from each patch available for each species 
  # Combines reflectance data with wavelength vector ranging from 300-700 nm
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  # Turns all negative reflectance values in dataframe to 0
  specs <- procspec(specs, fixneg="zero")
  
  # Creates a dataframe with just male specimens
  male_specs <- specs %>% select(!ends_with("f"))
  
  # Creates a dataframe from the male specimen data frame using only 
  # the crown patch of the bird
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  # Finds the rgb hex code for each of the crown patches
  rgb_colors <- spec2rgb(crown_data)
  # Adds names of the species to each hex color code
  names(rgb_colors) <- names(crown_data)[-1]
  
  # Verifies that dataframe has been created correctly
  head(crown_data)
})

```



### Step 1 Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}

# File pathway linking to the Thraupidae tree on laptop
treepath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# File pathway linking to the Thraupidae tree on PC
#treepath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# Reads Thraupidae tree into R
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)

# Creates a NEXUS tree file into working directory
write.nexus(tanagerTree, file = "tanagerTree.NEXUS")
```



### Step 2 Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify dataframe created correctly
head(tanData_filtered)

# Verifies that there are 0 species in dataframe that should not be there
(names(tanData_filtered[-1]) == tanager_species)

# Verifies that there are not any species have not been added to dataframe
length(names(tanData_filtered[-1])) == length(tanager_species)


```



### Step 3: Fitting Cubic Splines to the Tanager Reflectance and Log-Transformed Reflectance Data

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Cubic Splines to Tanager reflectance data

 # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 38 degrees of freedom (35 knots)
    # We use gls instead of lm, as our error structure fails the independence assumption
    # corAR1 was the error structure recommended for us to use
    # When using the corAR1 function, the argument value pertains to the type of autocorrelation present in the
    # corAR1 autocorrelation structure (at any given point, we only care about the autocorrelation of the next
    # surrounding point {x, x+1}).
    # For corAR1, I leave the 'value' argument at 0, given that it does not change any of the coefficient values
    # or the model score values. I will note that the error structure performs better (+ values) 
    # and worse (- values) at non-zero values, although I am unsure if this has any noteworthy
    # benefits to optimize. I need to talk to Professor Marc Suchard to clarify if leaving
    # it at the default of zero is acceptable.
    # With the form argument, I used form = ~ 1, form = ~ 300:700, and form = ~ wl,
    # and each produced identical results, so I will stick with the default of 
    # form = ~ 1 unless told otherwise.
    # For the final argument ('fixed'), fixed = TRUE produces lower residual standard
    # error values, but the model score performs lower than when fixed = FALSE.
    # I think this another question that needs to be asked as to which is better,
    # but for now, I will keep the default as fixed = FALSE.
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 38), correlation = 
                                          corAR1(form = ~ 1))

    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    # It is important to note that when working with trait data, we want to 
    # use the same basis matrix to preserve the same "trait space" (need to clarify
    # if this the correct thinking) between species. Thus, we make sure to keep the
    # same range of wavelength when proceeding forward (300-700 nm).
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC

    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC

    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      reflectance_coef = reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines_log <- function(wl, reflectance) {

    # Fit cubic spline to log-transformed reflectance values with 38 degrees of freedom (35 knots)
    cubic_spline_fit_log_reflectance <- gls((reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC

    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_log_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      log_reflectance_coef = log_reflectance_coef,
      log_reflectance_AIC = log_reflectance_AIC,
      log_reflectance_BIC = log_reflectance_BIC,
      log_reflectance_logLik = log_reflectance_logLik,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  
  # Here we need to make a separate dataframe for our log-transformed data
  # This is to convert any values less than 1 to 1 to avoid Inf/NaN errors during 
  # our log-transformation of the reflectance data

  # Creates a separate dataframe for only log-transformed data
  tanlogData_filtered <- tanData_filtered
  
  # Nested for loop to turn all data points < 1 into 1 to prevent any Inf/NaN errors
  for (i in 2:52){
    y <- as.numeric(i)
    for (j in 1:401){
      x <- as.numeric(j)
      matrix_position <- tanlogData_filtered[x,y]
      if (tanlogData_filtered[x,y] < 1){
        tanlogData_filtered[x,y] <- 1
      }
       else if (tanlogData_filtered[x,y] >= 1){
        tanlogData_filtered[x,y] <- matrix_position
       }
    }
}

  
  # This log-transforms every value in our dataframe
  tanlogData_filtered <- log(tanlogData_filtered)
  # This converts our wavelength data back to standard values
  # (300-700 nm)
  tanlogData_filtered$wl <- exp(tanlogData_filtered$wl)

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })

# Applies our spline fitting function to our log-transformed reflectance data for
# each species
  spline_results_log <- lapply(tanlogData_filtered[-1], function(reflectance) {
    fit_splines_log(tanlogData_filtered$wl, reflectance)
  })
  
```




# Step 4: Species plots of splines on refl. and log refl. data

```{r}

# Function that plots the splines from each dataset for all species
plot_splines_with_metrics <- function(species_name, wl, reflectance, log_reflectance, spline_results, spline_results_log, rgb_colors) {
  
  # Extracts a single species spline results from each dataset list
  result <- spline_results[[species_name]]
  log_result <- spline_results_log[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Plots Cubic Splines for Reflectance Data with model scores
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Plots Cubic Splines for log Reflectance data with model scores
plot(wl, log_reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Spline (log Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "log Reflectance (%)")
lines(wl, predict(log_result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(log_result$log_reflectance_AIC, 3), "BIC:", round(log_result$log_reflectance_BIC, 2), "logLik:", round(log_result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
}

# Takes above function and uses a for loop to get every species' spline results plotted
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}

# Takes the above plots and puts them onto a pdf
pdf("cubic_splines_refl&logrefl_with_metrics.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}
dev.off()


```


## Step 5 Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}

# Create the spline summary table with coefficients, degree,
# knot placements, rgb values, and goodness-of-fit metrics.
# Dataframe just extracts data from the species list data from 
# each of the respective spline results
spline_table <- data.frame(
  
  Species = names(spline_results),

  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results_log, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results_log, function(x) round(x$log_reflectance_AIC, 2)),  

  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results_log, function(x) round(x$log_reflectance_BIC, 2)),

   Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results_log, function(x) round(x$log_reflectance_logLik, 2)),

  Degree_Reflectance = sapply(spline_results, function(x) c(x$degree)),
  Degree_Log_Reflectance = sapply(spline_results_log, function(x) c(x$degree)),
  
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )



Internal_Knots = c(sapply(spline_results, function(x) c(x$internal_knots)))
Internal_Knots <- t(Internal_Knots)

Boundary_Knots = c(sapply(spline_results, function(x) c(x$boundary_knots)))
Boundary_Knots <- t(Boundary_Knots)

spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Boundary_Knots)

spline_table$Internal_Knots <- NA

for (i in 1:51){
  x <- c(spline_table[i,13:47])
  x <- as.numeric(x)
  spline_table[i,50] <- toString(x)
}

spline_table$Boundary_Knots <- NA
for (i in 1:51){
  x <- c(spline_table[i, 48:49])
  x <- as.numeric(x)
  spline_table[i,51] <- toString(x)
}

spline_table <- spline_table[,-c(13:49)]


# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

# Save the table as a CSV
write.csv(spline_table, "spline_summary_table.csv", row.names = FALSE)

# Fixing the PDF export by increasing the margins and adjusting the layout
pdf("spline_summary_table.pdf", width = 11, height = 8.5)
gridExtra::grid.table(spline_table, rows = NULL)
dev.off()

```