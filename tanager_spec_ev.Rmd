---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(nlme)
```

### initialization

```{r}
suppressMessages({
  ddPath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\RefDataSpeciesSummary_MatchingMF\\data"

  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  wl <- dat[[1]][, 1]
  dat <- sapply(dat, "[", -1)
  
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  specs <- procspec(specs, fixneg="zero")
  
  male_specs <- specs %>% select(!ends_with("f"))
  
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  rgb_colors <- spec2rgb(crown_data)
  names(rgb_colors) <- names(crown_data)[-1]
  
  head(crown_data)
})

```

### Step 1 Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}
treepath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)

write.nexus(tanagerTree, file = "tanagerTree.NEXUS")
```




### Step 2 Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify
head(tanData_filtered)


```

### Step 3: Fitting Natural and Cubic Splines to the Tanager Data

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Natural and Cubic Splines to the Tanager Data

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, goodness-of-fit metrics, and RGB colors
fit_splines <- function(wl, reflectance) {
  # Fit natural cubic spline
  natural_spline_fit <- lm((reflectance) ~ ns(wl, df = 10))
  
  # Fit cubic spline
  cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
  
  # Convert fitted splines to rspec and then to RGB hex codes
  natural_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(natural_spline_fit)), lim = c(300, 700))
  natural_rgb <- spec2rgb(natural_spline_rspec)
  
  cubic_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(cubic_spline_fit)), lim = c(300, 700))
  cubic_rgb <- spec2rgb(cubic_spline_rspec)
  
  # Extract coefficients
  natural_coef <- round(coef(natural_spline_fit), 2)
  cubic_coef <- round(coef(cubic_spline_fit), 2)
  
  # Calculate goodness-of-fit metrics
  natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
  cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
  
  natural_aic <- AIC(natural_spline_fit)
  cubic_aic <- AIC(cubic_spline_fit)
  
  return(list(
    natural_spline_fit = natural_spline_fit,
    cubic_spline_fit = cubic_spline_fit,
    natural_rgb = natural_rgb,
    cubic_rgb = cubic_rgb,
    natural_coef = natural_coef,
    cubic_coef = cubic_coef,
    natural_adj_r2 = natural_adj_r2,
    cubic_adj_r2 = cubic_adj_r2,
    natural_aic = natural_aic,
    cubic_aic = cubic_aic
  ))
}

# Apply the spline fitting function to each species
spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines(tanData_filtered$wl, reflectance)
})



```

Step 3b--making the species plots of natural and cubic spline

```{r}
plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Natural Spline
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Natural Spline -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$natural_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("Adj R2:", round(result$natural_adj_r2, 3), "AIC:", round(result$natural_aic, 2)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Cubic Spline
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Spline -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$cubic_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("Adj R2:", round(result$cubic_adj_r2, 3), "AIC:", round(result$cubic_aic, 2)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
}

for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

pdf("natural_vs_cubic_splines_with_metrics.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()


```


### Step 4: Plotting Spline Fits and Original Data in the Markdown Document

```{r, message=FALSE, warning=FALSE}
### Step 4: Calculate Average Splines and Standard Deviation

# Calculate the maximum reflectance across all splines
max_reflectance <- max(sapply(spline_results, function(result) {
  max(predict(result$natural_spline_fit), predict(result$cubic_spline_fit))
}))

# Initialize vectors to store average splines and standard deviations
natural_spline_avg <- numeric(length(tanData_filtered$wl))
cubic_spline_avg <- numeric(length(tanData_filtered$wl))
natural_spline_sd <- numeric(length(tanData_filtered$wl))
cubic_spline_sd <- numeric(length(tanData_filtered$wl))

# Calculate averages
for (result in spline_results) {
  natural_pred <- predict(result$natural_spline_fit)
  cubic_pred <- predict(result$cubic_spline_fit)
  
  natural_spline_avg <- natural_spline_avg + natural_pred
  cubic_spline_avg <- cubic_spline_avg + cubic_pred
}

# Convert sums to averages
natural_spline_avg <- natural_spline_avg / length(spline_results)
cubic_spline_avg <- cubic_spline_avg / length(spline_results)

# Calculate standard deviations
for (result in spline_results) {
  natural_pred <- predict(result$natural_spline_fit)
  cubic_pred <- predict(result$cubic_spline_fit)
  
  natural_spline_sd <- natural_spline_sd + (natural_pred - natural_spline_avg)^2
  cubic_spline_sd <- cubic_spline_sd + (cubic_pred - cubic_spline_avg)^2
}

natural_spline_sd <- sqrt(natural_spline_sd / (length(spline_results) - 1))
cubic_spline_sd <- sqrt(cubic_spline_sd / (length(spline_results) - 1))

### Correct for negative values in the average splines

# Convert the average natural and cubic splines to rspec objects
natural_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = natural_spline_avg), lim = c(300, 700))
cubic_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = cubic_spline_avg), lim = c(300, 700))

# Correct any negative values in the rspec objects
natural_spline_rspec <- procspec(natural_spline_rspec, fixneg = "zero")
cubic_spline_rspec <- procspec(cubic_spline_rspec, fixneg = "zero")

# Convert corrected rspec objects to RGB hex codes
natural_spline_rgb <- spec2rgb(natural_spline_rspec)
cubic_spline_rgb <- spec2rgb(cubic_spline_rspec)

### Step 4a: Plot Average Splines with Confidence Intervals

# Create a plot for the average natural spline with confidence intervals
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Average Natural Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(natural_spline_avg + natural_spline_sd, rev(natural_spline_avg - natural_spline_sd)), 
        col = adjustcolor(natural_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Create a plot for the average cubic spline with confidence intervals
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Average Cubic Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(cubic_spline_avg + cubic_spline_sd, rev(cubic_spline_avg - cubic_spline_sd)), 
        col = adjustcolor(cubic_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

# Save the hotspot plots to a PDF
pdf("spline_hotspots.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))  # Plot both splines side by side

# Average Natural Spline with Hotspots in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Average Natural Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(natural_spline_avg + natural_spline_sd, rev(natural_spline_avg - natural_spline_sd)), 
        col = adjustcolor(natural_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Average Cubic Spline with Hotspots in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Average Cubic Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(cubic_spline_avg + cubic_spline_sd, rev(cubic_spline_avg - cubic_spline_sd)), 
        col = adjustcolor(cubic_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()

### Step 4b: Plot Natural Spline Mean and Cubic Spline Mean with Species Overlaid

# Plot Natural Spline Mean with all species overlaid
par(mfrow = c(1, 2))

# Plot Natural Spline Mean with Species Overlaid
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$natural_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$natural_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline Mean with Species Overlaid
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$cubic_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$cubic_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

# Save the overlay plots to a PDF
pdf("spline_mean_with_species_overlay.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))

# Plot Natural Spline Mean with Species Overlaid in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$natural_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$natural_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline Mean with Species Overlaid in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$cubic_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$cubic_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()


```


### Step 4b Make a pair of plots of the natural and cubic spline where the spline is colored as a spec that is converted to its hsv value (make sure no negative values)

```{r, message=FALSE, warning=FALSE}
### Step 4b: Plot Natural Spline with Species Overlaid and Print to PDF

# Convert the natural spline to an rspec object and then to an RGB hex code
natural_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = natural_spline_avg), lim = c(300, 700))
natural_spline_rgb <- spec2rgb(natural_spline_rspec)

# Convert the cubic spline to an rspec object and then to an RGB hex code
cubic_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = cubic_spline_avg), lim = c(300, 700))
cubic_spline_rgb <- spec2rgb(cubic_spline_rspec)

# Plot the natural and cubic splines side by side in R Markdown
par(mfrow = c(1, 2))  # Arrange plots side by side

# Plot Natural Spline with Species Overlaid
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,  # Increased thickness
     main = "Natural Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))

# Loop through each species to plot their splines with slightly more visible transparency
for (species in names(spline_results)) {
  species_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$natural_spline_fit)), lim = c(300, 700))
  species_rgb <- spec2rgb(species_spline_rspec)
  
  # Adjust transparency to make species lines slightly more visible
  species_rgb_alpha <- adjustcolor(species_rgb, alpha.f = 0.4)  # Adjusted alpha for more visibility
  
  lines(tanData_filtered$wl, predict(spline_results[[species]]$natural_spline_fit), col = species_rgb_alpha)
}

# Re-plot the natural spline on top to ensure it stands out
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)  # Increased thickness

# Plot Cubic Spline with Species Overlaid
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,  # Increased thickness
     main = "Cubic Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))

# Loop through each species to plot their splines with slightly more visible transparency
for (species in names(spline_results)) {
  species_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$cubic_spline_fit)), lim = c(300, 700))
  species_rgb <- spec2rgb(species_spline_rspec)
  
  # Adjust transparency to make species lines slightly more visible
  species_rgb_alpha <- adjustcolor(species_rgb, alpha.f = 0.4)  # Adjusted alpha for more visibility
  
  lines(tanData_filtered$wl, predict(spline_results[[species]]$cubic_spline_fit), col = species_rgb_alpha)
}

# Re-plot the cubic spline on top to ensure it stands out
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)  # Increased thickness

# Save the plots to a PDF as well
pdf("natural_and_cubic_splines_with_species_overlay.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))  # Arrange plots side by side in the PDF

# Plot Natural Spline with Species Overlaid in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (species in names(spline_results)) {
  species_rgb_alpha <- adjustcolor(spec2rgb(as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$natural_spline_fit)), lim = c(300, 700))), alpha.f = 0.4)
  lines(tanData_filtered$wl, predict(spline_results[[species]]$natural_spline_fit), col = species_rgb_alpha)
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline with Species Overlaid in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (species in names(spline_results)) {
  species_rgb_alpha <- adjustcolor(spec2rgb(as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$cubic_spline_fit)), lim = c(300, 700))), alpha.f = 0.4)
  lines(tanData_filtered$wl, predict(spline_results[[species]]$cubic_spline_fit), col = species_rgb_alpha)
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()


```

### Step 5 Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}
# Open the PDF device
pdf("spline_fits_with_rgb_and_metrics.pdf", width = 12, height = 8)

# Set up the plotting area to show two plots per page
par(mfrow = c(1, 2))

# Loop over each species and plot the original data and spline fits side by side
for (species in names(spline_results)) {
  result <- spline_results[[species]]
  
  # Get the correct RGB color
  color <- rgb_colors[grep(species, names(rgb_colors))]
  
  # Plot original data and natural spline fit
  plot(tanData_filtered$wl, tanData_filtered[[species]], main = paste("Natural Spline Fit for", species),
       xlab = "Wavelength (nm)", ylab = "Reflectance", type = "o", col = color)
  lines(tanData_filtered$wl, predict(result$natural_spline_fit), col = "red", lwd = 2)
  mtext(paste("Adj R2:", round(result$natural_adj_r2, 3), "AIC:", round(result$natural_aic, 2)),
        side = 3, line = 0.5, cex = 0.7, col = "blue")
  
  # Plot original data and cubic spline fit
  plot(tanData_filtered$wl, tanData_filtered[[species]], main = paste("Cubic Spline Fit for", species),
       xlab = "Wavelength (nm)", ylab = "Reflectance", type = "o", col = color)
  lines(tanData_filtered$wl, predict(result$cubic_spline_fit), col = "green", lwd = 2)
  mtext(paste("Adj R2:", round(result$cubic_adj_r2, 3), "AIC:", round(result$cubic_aic, 2)),
        side = 3, line = 0.5, cex = 0.7, col = "blue")
}

# Close the PDF device
dev.off()

```


## Step 6 Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}
# Create the spline summary table with coefficients and goodness-of-fit metrics
spline_table <- data.frame(
  Species = names(spline_results),
  Natural_Spline_Coefficients = sapply(spline_results, function(x) paste(x$natural_coef, collapse = ", ")),
  Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
  Natural_Adj_R2 = sapply(spline_results, function(x) round(x$natural_adj_r2, 3)),
  Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
  Natural_AIC = sapply(spline_results, function(x) round(x$natural_aic, 2)),
  Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
)

# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

# Save the table as a CSV
write.csv(spline_table, "spline_summary_table.csv", row.names = FALSE)

# Fixing the PDF export by increasing the margins and adjusting the layout
pdf("spline_summary_table.pdf", width = 11, height = 8.5)
gridExtra::grid.table(spline_table, rows = NULL)
dev.off()

```


# Step 6b: Export Spline Data to CSV
```{r}
spline_export <- lapply(names(spline_results), function(species_name) {
  result <- spline_results[[species_name]]
  data.frame(
    Species = species_name,
    Wavelength = tanData_filtered$wl,
    Natural_Spline_Fitted = predict(result$natural_spline_fit),
    Cubic_Spline_Fitted = predict(result$cubic_spline_fit),
    Natural_Spline_Coefficients = paste(result$natural_coef, collapse = ", "),
    Cubic_Spline_Coefficients = paste(result$cubic_coef, collapse = ", "),
    Natural_Knots = paste(result$natural_knots, collapse = ", "),
    Cubic_Knots = paste(result$cubic_knots, collapse = ", ")
  )
})
# Combine all species data into one dataframe
spline_export_df <- do.call(rbind, spline_export)
# Save the data to a CSV file
write.csv(spline_export_df, "spline_data_for_reconstruction.csv", row.names = FALSE)
# Inform the user
cat("Spline data for reconstruction has been saved to 'spline_data_for_reconstruction.csv'.\\\\n")
4:33
# Step 6c: Reconstruct and Plot Splines from CSV
spline_data <- read.csv("spline_data_for_reconstruction.csv")
# Function to plot the splines from the CSV data
plot_spline_from_csv <- function(species_name, spline_data) {
  species_data <- spline_data %>% filter(Species == species_name)
  # Plot Natural Spline
  plot(species_data$Wavelength, species_data$Natural_Spline_Fitted, type = "l", col = "blue", lwd = 2,
       main = paste("Natural Spline -", species_name),
       xlab = "Wavelength (nm)", ylab = "Reflectance")
  # Plot Cubic Spline
  lines(species_data$Wavelength, species_data$Cubic_Spline_Fitted, col = "red", lwd = 2)
  legend("topright", legend = c("Natural Spline", "Cubic Spline"), col = c("blue", "red"), lwd = 2)
}
# Plot all species
for (species_name in unique(spline_data$Species)) {
  plot_spline_from_csv(species_name, spline_data)
}

```

### Step 7 Save data objects for beast run


```{r, message=FALSE, warning=FALSE}

# Step 7: Save the Tanager Tree and Data as an R Data Object

# Save the tree, filtered spectral data, and spline results into an RData file
save(tanagerTree, tanData_filtered, spline_results, file = "tanager_analysis_results.RData")

# Inform the user that the data has been saved
cat("The Tanager tree, data, and spline results have been saved to 'tanager_analysis_results.RData'.\\\\n")

```

### Step 8 Getting things ready for BEAST

```{r, message=FALSE, warning=FALSE}
# Export spline coefficients as a CSV file for BEAST
spline_traits <- data.frame(Species = names(spline_results))

# Add the coefficients as traits
for (i in 1:length(spline_results)) {
  spline_traits[i, "Natural_Spline_1"] = spline_results[[i]]$natural_coef[2]
  spline_traits[i, "Natural_Spline_2"] = spline_results[[i]]$natural_coef[3]
  spline_traits[i, "Natural_Spline_3"] = spline_results[[i]]$natural_coef[4]
  spline_traits[i, "Natural_Spline_4"] = spline_results[[i]]$natural_coef[5]
  spline_traits[i, "Cubic_Spline_1"] = spline_results[[i]]$cubic_coef[2]
  spline_traits[i, "Cubic_Spline_2"] = spline_results[[i]]$cubic_coef[3]
  spline_traits[i, "Cubic_Spline_3"] = spline_results[[i]]$cubic_coef[4]
}

# Save the spline traits to a CSV file
write.csv(spline_traits, "spline_coefficients_for_BEAST.csv", row.names = FALSE)

```

### Step 9 BEAST xml

not sure yet how to do this but here is the general approach....

Load Tree and Data:
Load your phylogenetic tree (e.g., tanagerTree) and the CSV file containing the traits.
Define the Traits:
In the XML file, define each spline coefficient as a separate trait. If you want to estimate a single evolutionary rate for all coefficients, you can define them as independent traits.
Model Specification:
For each trait, specify a Brownian motion model (bm).
If you want to treat the coefficients independently but estimate the same evolutionary rate for all, use a shared rate parameter across the traits.
Rate Estimation:
Define a hyperparameter for the rate of evolution and link it to all the traits.
Alternatively, run separate BEAST analyses for each trait if you want to estimate the rates independently.


```{xml}
<trait id="natural_spline_1" spec="RealParameter" dimension="N">
    <statefile name="state" startstate="true"/>
</trait>

<distribution id="prior" spec="util.CompoundDistribution">
    <distribution spec="beast.math.distributions.MRCAPrior" id="TMRCA">
        <tree topologies="$tanagerTree" spec="TreeLikelihood">
            <distribution spec="beast.evolution.likelihood.MG94Likelihood" id="treeModel">
                <data id="natural_spline_1.data" spec="beast.evolution.alignment.Alignment" dataType="continuous">
                    <sequence taxon="species1" totalcount="4" value="coeff1, coeff2, coeff3, coeff4"/>
                    <sequence taxon="species2" totalcount="4" value="coeff1, coeff2, coeff3, coeff4"/>
                </data>
            </distribution>
        </tree>
    </distribution>
</distribution>

<run id="mcmc" spec="MCMC">
    <state>
        <parameter id="rate" name="stateNode" dimension="1">0.1</parameter>
    </state>

    <posterior>
        <distribution id="posterior" spec="util.CompoundDistribution">
            <prior id="prior" spec="beast.math.distributions.MRCAPrior" tree="@treeModel">
                <normalPrior mean="0" stdev="1" name="distr"/>
            </prior>
            <likelihood id="likelihood" spec="util.CompoundDistribution">
                <distribution id="treeLikelihood" spec="TreeLikelihood">
                    <data id="alignment" spec="Alignment" dataType="continuous"/>
                    <siteModel id="SiteModel" spec="SiteModel" gammaCategoryCount="4">
                        <substitutionModel id="F81" spec="F81"/>
                    </siteModel>
                </distribution>
            </likelihood>
        </distribution>
    </posterior>
</run>
```
You will need to replicate this setup for each coefficient, ensuring that they either share or have independent rate parameters depending on your choice.

3. Run BEAST

Load the XML into BEAST: Once the XML is set up, load it into BEAST.
Run the Analysis: Start the analysis to estimate the evolutionary rates.
4. Post-Analysis

After the BEAST run completes, you can analyze the results using Tracer to check the estimated rates and other parameters.


# Nick's Work

```{r setup, include=FALSE}
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(grid)
```


## Testing DF range in ns Function

```{r, warning=FALSE}



# for loop to collect model details as we increase the degrees of freedom

for (i in 1:1){
  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit natural cubic spline
    natural_spline_fit <- lm(reflectance ~ ns(wl, df = 1))
    
    # Fit cubic spline
    cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
    
    # Extract coefficients
    natural_coef <- round(coef(natural_spline_fit), 2)
    cubic_coef <- round(coef(cubic_spline_fit), 2)
    
    # Calculate goodness-of-fit metrics
    natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
    cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
    
    natural_aic <- AIC(natural_spline_fit)
    cubic_aic <- AIC(cubic_spline_fit)
    
    return(list(
      natural_spline_fit = natural_spline_fit,
      cubic_spline_fit = cubic_spline_fit,
      natural_coef = natural_coef,
      cubic_coef = cubic_coef,
      natural_adj_r2 = natural_adj_r2,
      cubic_adj_r2 = cubic_adj_r2,
      natural_aic = natural_aic,
      cubic_aic = cubic_aic
    ))
  }
  
  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })
  
  spline_table <- data.frame(
    Species = names(spline_results),
    Natural_Spline_Coefficients = sapply(spline_results, function(x) paste(x$natural_coef, collapse = ", ")),
    Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
    Natural_Adj_R2 = sapply(spline_results, function(x) round(x$natural_adj_r2, 3)),
    Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
    Natural_AIC = sapply(spline_results, function(x) round(x$natural_aic, 2)),
    Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
  )
  
  # Remove row names
  rownames(spline_table) <- NULL
  
  # Display the table in the document without row names
  kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
  # Save the table as a CSV
  write.csv(spline_table, "spline_df_summary_table.csv", row.names = FALSE)
  
# for loop up above sets up dataframe for the data from the for loop below to attach to  
  
  for (j in 2:41){
    # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
    fit_splines_df <- function(wl, reflectance) {
      # Fit natural cubic spline
      natural_spline_fit <- lm(reflectance ~ ns(wl, df = j))
      
      # Fit cubic spline
      cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
      
      # Extract coefficients
      natural_coef <- round(coef(natural_spline_fit), 2)
      cubic_coef <- round(coef(cubic_spline_fit), 2)
      
      # Calculate goodness-of-fit metrics
      natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
      cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
      
      natural_aic <- AIC(natural_spline_fit)
      cubic_aic <- AIC(cubic_spline_fit)
      
      return(list(
        natural_spline_fit = natural_spline_fit,
        cubic_spline_fit = cubic_spline_fit,
        natural_coef = natural_coef,
        cubic_coef = cubic_coef,
        natural_adj_r2 = natural_adj_r2,
        cubic_adj_r2 = cubic_adj_r2,
        natural_aic = natural_aic,
        cubic_aic = cubic_aic
      ))
    }
    
    # Apply the spline fitting function to each species
    spline_results_df <- lapply(tanData_filtered[-1], function(reflectance) {
      fit_splines_df(tanData_filtered$wl, reflectance)
    })
    
    spline_table_df <- data.frame(
      Species = names(spline_results_df),
      Natural_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$natural_coef, collapse = ", ")),
      Cubic_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$cubic_coef, collapse = ", ")),
      Natural_Adj_R2 = sapply(spline_results_df, function(x) round(x$natural_adj_r2, 3)),
      Cubic_Adj_R2 = sapply(spline_results_df, function(x) round(x$cubic_adj_r2, 3)),
      Natural_AIC = sapply(spline_results_df, function(x) round(x$natural_aic, 2)),
      Cubic_AIC = sapply(spline_results_df, function(x) round(x$cubic_aic, 2))
    )
    
    # Remove row names
    rownames(spline_table_df) <- NULL
    
    # Display the table in the document without row names
    kable(spline_table_df, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
      kable_styling(bootstrap_options = "striped", full_width = F)
    
    if (j == 2){
    spline_table_df_all <- rbind(spline_table, spline_table_df)
    rm(spline_table)}
    else if (j > 2){
    spline_table_df_all <- rbind(spline_table_df_all, spline_table_df)
    }
    # Save the table as a CSV
    write.csv(spline_table_df_all, "spline_df_summary_table.csv", row.names = FALSE)
    
   
    }
    
}
  

dev.off()
# ordering by species the collection of spline functions w/ varying df (3:41)
spline_table_df_ordered <- arrange(spline_table_df_all, spline_table_df_all$Species)

df <- rep(c(1:41),51)

spline_table_df_ordered <- cbind(df, spline_table_df_ordered)
  # Display the table in the document without row names
  kable(spline_table_df_ordered, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = FALSE)

```
## Optimizing (# of knots/df) with ns function

```{r}

load(file = "quick_reload.RData")

# 0.9 threshold
r2_optimization <- subset(spline_table_df_ordered, spline_table_df_ordered$Natural_Adj_R2 >= 0.9)

length(unique(r2_optimization$Species))
length(unique(spline_table_df_ordered$Species))
unique_r2_optimization_Species <- unique(r2_optimization$Species)
unique_spline_table_df_ordered_Species <- unique(spline_table_df_ordered$Species)
setdiff(unique_spline_table_df_ordered_Species, unique_r2_optimization_Species)

TanArg_alldf <- spline_table_df_ordered %>%
  filter(Species == "TanArg") %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)

TanArg_alldf <- TanArg_alldf %>%
  filter(Natural_Adj_R2 == max(Natural_Adj_R2)) %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)


TanMex_alldf <- spline_table_df_ordered %>%
  filter(Species == "TanMex") %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)

TanMex_alldf <- TanMex_alldf %>%
  filter(Natural_Adj_R2 == max(Natural_Adj_R2)) %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)

TanArg_alldf
TanMex_alldf

names(unique_r2_optimization_Species) <- unique_r2_optimization_Species

r2_optimal_df_0.9 <- NULL

for (species_name in names(unique_r2_optimization_Species)){
name_vector <- as.character(species_name)
x <- spline_table_df_ordered %>%
  filter(Species == name_vector) %>%
  filter(Natural_Adj_R2 >= 0.9) %>%
  filter(df == min(df)) %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)
  
r2_optimal_df_0.9 <- rbind(r2_optimal_df_0.9, x)  
  
}


hist(r2_optimal_df_0.9$df, breaks = seq(0, 40, length.out = 40), right = FALSE)


r2_optimal_df_0.95 <- NULL

for (species_name in names(unique_r2_optimization_Species)){
name_vector <- as.character(species_name)
x <- spline_table_df_ordered %>%
  filter(Species == name_vector) %>%
  filter(Natural_Adj_R2 >= 0.95) %>%
  filter(df == min(df)) %>%
  select(df, Species, Natural_Spline_Coefficients, Cubic_Spline_Coefficients, Natural_Adj_R2, Cubic_Adj_R2, Natural_AIC, Cubic_AIC)
  
r2_optimal_df_0.95 <- rbind(r2_optimal_df_0.95, x)  
  
}

hist(r2_optimal_df_0.95$df, breaks = seq(0, 41, length.out = 41), right = FALSE)
length(r2_optimal_df_0.95$Species)


rgb_colors_names <- as.character(names(rgb_colors))
position_vector <- NULL
for (species_name in names(unique_r2_optimization_Species)){
  name_vector <- as.character(species_name)
  position <- (which(rgb_colors_names == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- rgb_colors[c(position_vector)]








ggplot(data = r2_optimal_df_0.9, aes(x = df, fill = Species)) + geom_histogram(bins = 40) + scale_fill_manual(values = tanager_subset_colors) + theme(legend.key.size = unit(0.5, "cm")) + ggtitle("DF Optimization", subtitle = "Min DF for R^2 >= 0.9 ") + xlab("Degrees of Freedom") + ylab("Frequency")


```







## Testing DF range in bs Function

```{r, message=FALSE, warning=FALSE}



# for loop to collect model details as we increase the degrees of freedom

for (i in 1:1){
  # Function to fit a b spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit b cubic spline
    b_spline_fit <- lm(reflectance ~ bs(wl, df = 1))
    
    # Fit cubic spline
    cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
    
    # Extract coefficients
    b_coef <- round(coef(b_spline_fit), 2)
    cubic_coef <- round(coef(cubic_spline_fit), 2)
    
    # Calculate goodness-of-fit metrics
    b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
    cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
    
    b_aic <- AIC(b_spline_fit)
    cubic_aic <- AIC(cubic_spline_fit)
    
    return(list(
      b_spline_fit = b_spline_fit,
      cubic_spline_fit = cubic_spline_fit,
      b_coef = b_coef,
      cubic_coef = cubic_coef,
      b_adj_r2 = b_adj_r2,
      cubic_adj_r2 = cubic_adj_r2,
      b_aic = b_aic,
      cubic_aic = cubic_aic
    ))
  }
  
  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })
  
  spline_table_df_bs <- data.frame(
    Species = names(spline_results),
    b_Spline_Coefficients = sapply(spline_results, function(x) paste(x$b_coef, collapse = ", ")),
    Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
    b_Adj_R2 = sapply(spline_results, function(x) round(x$b_adj_r2, 3)),
    Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
    b_AIC = sapply(spline_results, function(x) round(x$b_aic, 2)),
    Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
  )
  
  # Remove row names
  rownames(spline_table_df_bs) <- NULL
  
  # Display the table in the document without row names
  kable(spline_table_df_bs, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
  # Save the table as a CSV
  write.csv(spline_table_df_bs, "b_spline_df_summary_table.csv", row.names = FALSE)
  
# for loop up above sets up dataframe for the data from the for loop below to attach to  
  
  for (j in 2:41){
    # Function to fit a b spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
    fit_splines_df <- function(wl, reflectance) {
      # Fit b cubic spline
      b_spline_fit <- lm(reflectance ~ bs(wl, df = j))
      
      # Fit cubic spline
      cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
      
      # Extract coefficients
      b_coef <- round(coef(b_spline_fit), 2)
      cubic_coef <- round(coef(cubic_spline_fit), 2)
      
      # Calculate goodness-of-fit metrics
      b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
      cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
      
      b_aic <- AIC(b_spline_fit)
      cubic_aic <- AIC(cubic_spline_fit)
      
      return(list(
        b_spline_fit = b_spline_fit,
        cubic_spline_fit = cubic_spline_fit,
        b_coef = b_coef,
        cubic_coef = cubic_coef,
        b_adj_r2 = b_adj_r2,
        cubic_adj_r2 = cubic_adj_r2,
        b_aic = b_aic,
        cubic_aic = cubic_aic
      ))
    }
    
    # Apply the spline fitting function to each species
    spline_results_df <- lapply(tanData_filtered[-1], function(reflectance) {
      fit_splines_df(tanData_filtered$wl, reflectance)
    })
    
    spline_table_df <- data.frame(
      Species = names(spline_results_df),
      b_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$b_coef, collapse = ", ")),
      Cubic_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$cubic_coef, collapse = ", ")),
      b_Adj_R2 = sapply(spline_results_df, function(x) round(x$b_adj_r2, 3)),
      Cubic_Adj_R2 = sapply(spline_results_df, function(x) round(x$cubic_adj_r2, 3)),
      b_AIC = sapply(spline_results_df, function(x) round(x$b_aic, 2)),
      Cubic_AIC = sapply(spline_results_df, function(x) round(x$cubic_aic, 2))
    )
    
    # Remove row names
    rownames(spline_table_df) <- NULL
    
    # Display the table in the document without row names
    kable(spline_table_df, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
      kable_styling(bootstrap_options = "striped", full_width = F)
    
    if (j == 2){
    spline_table_df_all <- rbind(spline_table_df_bs, spline_table_df)
    rm(spline_table_df_bs)}
    else if (j > 2){
    spline_table_df_all <- rbind(spline_table_df_all, spline_table_df)
    }
    # Save the table as a CSV
    write.csv(spline_table_df_all, "spline_df_summary_table.csv", row.names = FALSE)
    
   
    }
    
}
  

dev.off()
# ordering by species the collection of spline functions w/ varying df (3:41)
spline_table_df_ordered_with_bs <- arrange(spline_table_df_all, spline_table_df_all$Species)

degrees_of_freedom <- rep(c(1:41),51)

spline_table_df_ordered_with_bs <- cbind(degrees_of_freedom, spline_table_df_ordered_with_bs)
  # Display the table in the document without row names
  kable(spline_table_df_ordered_with_bs, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

```



## Comparing results between ns and bs functions

```{r, message=FALSE, warning=FALSE}


spline_table_df_ordered <- cbind(spline_table_df_ordered, spline_table_df_ordered_with_bs[,c(3,5,7)])

spline_table_df_ordered <- spline_table_df_ordered[,c(1,2,3,9,4,5,10,6,7,11,8)]

 # Display the table in the document without row names
  kable(spline_table_df_ordered, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

```


## How does increasing df in ns and bs function impact goodness-of-fit metrics?

```{r}

head(spline_table_df_ordered)

position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(rgb_colors_names == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- rgb_colors[c(position_vector)]

name_vector <- NULL

par(mfrow=c(2,2), mar = c(5.1, 5.1, 2.1, 1.1))

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  
  gof_metrics <- spline_table_df_ordered %>%
    filter(Species == name_vector) %>%
    select(df, Species, Natural_Spline_Coefficients, b_Spline_Coefficients, 
           Cubic_Spline_Coefficients, Natural_Adj_R2, b_Adj_R2 ,Cubic_Adj_R2, 
           Natural_AIC, b_AIC ,Cubic_AIC)
  
  plot(x = gof_metrics$df, y = gof_metrics$Natural_Adj_R2, main = paste(name_vector, "Natural Spline", collapse = ""), pch = 19, col = c(tanager_subset_colors[name_vector]), xlab = "", ylab = expression("R" ^  2), ylim = c(min(c(gof_metrics$Natural_Adj_R2, gof_metrics$b_Adj_R2)), max(c(gof_metrics$Natural_Adj_R2, gof_metrics$b_Adj_R2))))
  
     plot(x = gof_metrics$df, y = gof_metrics$b_Adj_R2, main = paste(name_vector, "Basis Spline"), col = c(tanager_subset_colors[name_vector]), pch = 19, xlab = "", ylab = "", ylim = c(min(c(gof_metrics$Natural_Adj_R2, gof_metrics$b_Adj_R2)), max(c(gof_metrics$Natural_Adj_R2, gof_metrics$b_Adj_R2))))
     
   plot(x = gof_metrics$df, y = gof_metrics$Natural_AIC, col = c(tanager_subset_colors[name_vector]), ylab = "AIC Scores", xlab = "Degrees of Freedom", pch = 19, ylim = c(min(c(gof_metrics$Natural_AIC, gof_metrics$b_AIC)), max(c(gof_metrics$Natural_AIC, gof_metrics$b_AIC))))

  plot(x = gof_metrics$df, y = gof_metrics$b_AIC, col = c(tanager_subset_colors[name_vector]), ylab = "", xlab = "Degrees of Freedom", pch = 19, ylim = c(min(c(gof_metrics$Natural_AIC, gof_metrics$b_AIC)), max(c(gof_metrics$Natural_AIC, gof_metrics$b_AIC))))
}

par(mfrow=c(1,1))

```




## Knot placement comparison : Natural Splines
```{r}
# NOTE: Run chunks initialization through Step 3 if working on this chunk



# function that records spline data
# records degree of function, # of internal and boundary knots and their placement
natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = 7)

  natural_spline_fit_data <- attributes(natural_spline)
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots
  ))
    
}

# applies the above function to tanager dataset
natural_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  natural_spline_data(tanData_filtered$wl, reflectance)
}
)


# Determination of the boundary knots and that their location is uniform for each species

# Data frame of the data
internal_knots_placement <- NULL

# Vector to store temporary data from for loop for the data frame
placeholder_vector <- NULL

# For loop that gathers the natural spline data
for (species_name in names(spline_results)){
  placeholder_vector <- natural_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}

# Converts the data into a data frame and applies species' names to the rows
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)

# Verification that internal knot placement is uniform

# Vector that captures the df used in for the natural spline
dimensions <- dim(internal_knots_placement)

# Vector that holds the knot placements
knots_vector <- NA

# For loop that turns the data frame into a vector
# Uses dimensions[2] for versatility (can be used for any df)
for (i in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,i])
  knots_vector <- c(knots_vector,x)
}

# NA omission
knots_vector <- na.omit(knots_vector)

# Visualization that data is uniform
hist(knots_vector, main = "Internal Knots Placement for Each Species", col = "yellow",
     ylab = "Frequency", xlab = "Wavelength (nm)")

# Further confirmation using logical vectors

# Turn the knots vector into a data frame to use count function
knots_dataframe <- data.frame(knots_vector)

# Counts the # of values for each knot's wavelength placement 
knots_counts <- knots_dataframe %>% count(knots_vector)

# # of species in our data
# Each wavelength should appear this amount of times if the knot placement is uniform
length(names(spline_results))

# For loop to verify that each wavelength appears 51 times
# If so, we should see 4 TRUEs as the output
for (i in 1:dimensions[2]){
  print(length(names(spline_results)) == knots_counts[i,2])
}


# For loop that looks at the degrees of freedom from 2:42
# Presently, there is a section for graphing each outcome but does not use space
# efficiently. Still a work in progress. The rest works as intended
for (i in 2:41){
  natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = i)

  natural_spline_fit_data <- attributes(natural_spline)
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots
  ))
    
}

natural_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  natural_spline_data(tanData_filtered$wl, reflectance)
}
)


internal_knots_placement <- NULL
placeholder_vector <- NULL
for (species_name in names(spline_results)){
  placeholder_vector <- natural_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)
head(internal_knots_placement)


par(mfrow=c(2,2))
dimensions <- dim(internal_knots_placement)
knots_vector <- NA
for (j in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,j])
  knots_vector <- c(knots_vector,x)
  }
knots_vector <- na.omit(knots_vector)

#hist(knots_vector, main = "Internal Knots Placement", col = "yellow",
#     ylab = "Frequency", xlab = "Wavelength (nm)", breaks = seq(300,700, length.out = #i), right = TRUE)


knots_dataframe <- data.frame(knots_vector)
knots_counts <- knots_dataframe %>% count(knots_vector)


# Created a system to verify each case (# of df) has uniform internal knot placement
# that does not lead to hundreds of TRUEs in the output

# Check vector that is the size of df
checker <- rep(NA, dimensions[2])

# For loop that checks if the length of each knot placement is equivalent to the # of     species
for (k in 1:dimensions[2]){
  if (length(names(spline_results)) != knots_counts[k,2]){
  checker[k] <- FALSE
  }
  
  if (length(names(spline_results)) == knots_counts[k,2]){
  checker[k] <- TRUE
  }

  }


# For loop to reduce the size of checker vector and further verify that all values are    TRUE
for (k in 1:dimensions[2]){
  if (checker[k] == TRUE){
    checker[k] <- NA
  }
}

# Removes all NA values
checker <- na.omit(checker)

# If all values are removed, then all knot placements are uniform
# Prints a singular output for each df case rather than df outputs
for (i in 1:1){
  if (length(checker) == 0){
    print("Knot Placements are Uniform")
  }
}


par(mfrow=c(1,1))

}

```


## Knot placement comparison : B-splines
```{r}
# NOTE: Run chunks initialization through Step 3 if working on this chunk



# function that records spline data
# records degree of function, # of internal and boundary knots and their placement
b_spline_data <- function(wl, reflectance){
  
  b_spline <- bs(wl, df = 5)

  b_spline_fit_data <- attributes(b_spline)
  
  return(list(
    degree = b_spline_fit_data$degree,
    internal_knots = b_spline_fit_data$knots,
    boundary_knots = b_spline_fit_data$Boundary.knots
  ))
    
}

# applies the above function to tanager dataset
b_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  b_spline_data(tanData_filtered$wl, reflectance)
}
)


# Determination of the boundary knots and that their location is uniform for each species

# Data frame of the data
internal_knots_placement <- NULL

# Vector to store temporary data from for loop for the data frame
placeholder_vector <- NULL

# For loop that gathers the b spline data
for (species_name in names(spline_results)){
  placeholder_vector <- b_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}

# Converts the data into a data frame and applies species' names to the rows
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)

# Verification that internal knot placement is uniform

# Vector that captures the df used in for the b spline
dimensions <- dim(internal_knots_placement)

# Vector that holds the knot placements
knots_vector <- NA

# For loop that turns the data frame into a vector
# Uses dimensions[2] for versatility (can be used for any df)
for (i in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,i])
  knots_vector <- c(knots_vector,x)
}

# NA omission
knots_vector <- na.omit(knots_vector)

# Visualization that data is uniform
hist(knots_vector, main = "Internal Knots Placement for Each Species", col = "yellow",
     ylab = "Frequency", xlab = "Wavelength (nm)")

# Further confirmation using logical vectors

# Turn the knots vector into a data frame to use count function
knots_dataframe <- data.frame(knots_vector)

# Counts the # of values for each knot's wavelength placement 
knots_counts <- knots_dataframe %>% count(knots_vector)

# # of species in our data
# Each wavelength should appear this amount of times if the knot placement is uniform
length(names(spline_results))

# For loop to verify that each wavelength appears 51 times
# If so, we should see 4 TRUEs as the output
for (i in 1:dimensions[2]){
  print(length(names(spline_results)) == knots_counts[i,2])
}


# For loop that looks at the degrees of freedom from 2:42
# Presently, there is a section for graphing each outcome but does not use space
# efficiently. Still a work in progress. The rest works as intended
for (i in 6:41){
  b_spline_data <- function(wl, reflectance){
  
  b_spline <- bs(wl, df = i)

  b_spline_fit_data <- attributes(b_spline)
  
  return(list(
    degree = b_spline_fit_data$degree,
    internal_knots = b_spline_fit_data$knots,
    boundary_knots = b_spline_fit_data$Boundary.knots
  ))
    
}

b_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  b_spline_data(tanData_filtered$wl, reflectance)
}
)


internal_knots_placement <- NULL
placeholder_vector <- NULL
for (species_name in names(spline_results)){
  placeholder_vector <- b_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)
head(internal_knots_placement)


par(mfrow=c(2,2))
dimensions <- dim(internal_knots_placement)
knots_vector <- NA
for (j in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,j])
  knots_vector <- c(knots_vector,x)
  }
knots_vector <- na.omit(knots_vector)

#hist(knots_vector, main = "Internal Knots Placement", col = "yellow",
#     ylab = "Frequency", xlab = "Wavelength (nm)", breaks = seq(300,700, length.out = #i), right = TRUE)


knots_dataframe <- data.frame(knots_vector)
knots_counts <- knots_dataframe %>% count(knots_vector)


# Created a system to verify each case (# of df) has uniform internal knot placement
# that does not lead to hundreds of TRUEs in the output

# Check vector that is the size of df
checker <- rep(NA, dimensions[2])

# For loop that checks if the length of each knot placement is equivalent to the # of     species
for (k in 1:dimensions[2]){
  if (length(names(spline_results)) != knots_counts[k,2]){
  checker[k] <- FALSE
  }
  
  if (length(names(spline_results)) == knots_counts[k,2]){
  checker[k] <- TRUE
  }

  }


# For loop to reduce the size of checker vector and further verify that all values are    TRUE
for (k in 1:dimensions[2]){
  if (checker[k] == TRUE){
    checker[k] <- NA
  }
}

# Removes all NA values
checker <- na.omit(checker)

# If all values are removed, then all knot placements are uniform
# Prints a singular output for each df case rather than df outputs
for (i in 1:1){
  if (length(checker) == 0){
    print("Knot Placements are Uniform")
  }
}


par(mfrow=c(1,1))

}

```

```{r, message=FALSE, warning=FALSE}


pdf(file = "Internal Knot Placement Uniformity Verification B-splines", width = 8, height = 12,paper = "letter", )
for (i in 6:41){
  b_spline_data <- function(wl, reflectance){
  
  b_spline <- bs(wl, df = i)

  b_spline_fit_data <- attributes(b_spline)
  
  return(list(
    degree = b_spline_fit_data$degree,
    internal_knots = b_spline_fit_data$knots,
    boundary_knots = b_spline_fit_data$Boundary.knots
  ))
    
}

b_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  b_spline_data(tanData_filtered$wl, reflectance)
}
)


internal_knots_placement <- NULL
placeholder_vector <- NULL
for (species_name in names(spline_results)){
  placeholder_vector <- b_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)


dimensions <- dim(internal_knots_placement)
knots_vector <- NA
for (j in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,j])
  knots_vector <- c(knots_vector,x)
  }
knots_vector <- na.omit(knots_vector)


hist(knots_vector, main = "Internal Knots Placement", col = i,
    ylab = "Frequency", xlab = "Wavelength (nm)", breaks = seq(300,700, length.out = i), right = TRUE)
}
dev.off()
dev.off()

```

## Are spline coefficients held constant if the amount of knots increased?
```{r, warning=FALSE}

tanager_subset <- tanData_filtered[,c(1,2,4,5,8,12,19,31)]
names(tanager_subset[-1])

  natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = 5)

  natural_spline_fit_data <- attributes(natural_spline)
  
  natural_spline_lm <- lm(reflectance ~ ns(wl, df = 5))
  
  natural_spline_lm_data <- summary(lm(reflectance ~ ns(wl, df = 5)))
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots,
    natural_spline_adj_r2 = natural_spline_lm_data$adj.r.squared,
    natural_spline_coef = round(coef(natural_spline_lm), 3)
    
  ))
  
}

coefficient_data <- NULL  
placeholder_vector <- NULL
knot_placement <- NULL
placeholder_vector_knots <- NULL

for (i in 10:5){

  natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = i)

  natural_spline_fit_data <- attributes(natural_spline)
  
  natural_spline_lm <- lm(reflectance ~ ns(wl, df = i))
  
  natural_spline_lm_data <- summary(lm(reflectance ~ ns(wl, df = i)))
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots,
    natural_spline_adj_r2 = natural_spline_lm_data$adj.r.squared,
    natural_spline_coef = round(coef(natural_spline_lm), 3)
    
  ))
  
}

natural_spline_results_TanCyo <- natural_spline_data(tanager_subset$wl, tanager_subset$TanCyo)

placeholder_vector <- natural_spline_results_TanCyo$natural_spline_coef

coefficient_data <- rbind(coefficient_data, placeholder_vector)
  

placeholder_vector_knots <- natural_spline_results_TanCyo$internal_knots

knot_placement <- rbind(knot_placement, placeholder_vector_knots)

}

coefficient_data <- data.frame(coefficient_data)

knot_placement <- data.frame(knot_placement)

rownames(coefficient_data) <- c("df=10", "df=9","df=8","df=7","df=6","df=5")

coefficient_data[2,c(11)] <- NA
coefficient_data[3,c(11,10)] <- NA
coefficient_data[4,c(11,10,9)] <- NA
coefficient_data[5,c(11,10,9,8)] <- NA
coefficient_data[6,c(11,10,9,8,7)] <- NA


knot_placement[2,c(9)] <- NA
knot_placement[3,c(9,8)] <- NA
knot_placement[4,c(9,8,7)] <- NA
knot_placement[5,c(9,8,7,6)] <- NA
knot_placement[6,c(9,8,7,6,5)] <- NA

print(coefficient_data)
print(knot_placement)

```







# AIC and R^2 distributions (ns vs. cubic)
```{r, message = FALSE, warning=FALSE}
# Run everything through chunk Step 6



model_scoring <- spline_table[,c(1,4:7)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model = min(c(Natural_AIC, Cubic_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,6] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,6] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,6] == model_scoring[i,5] & model_scoring[i,6] == model_scoring[i,4]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[7] <- "Preferred_Model_Name"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 0] <- "Natural"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 1] <- "Cubic"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 2] <- "Either"



model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Best_Fit = max(c(Natural_Adj_R2, Cubic_Adj_R2)))

best_fit_model <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    best_fit_model[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    best_fit_model[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    best_fit_model[i] <- 2
  }
    }


model_scoring <- cbind(model_scoring, best_fit_model)
column_names <- colnames(model_scoring)
column_names[9] <- "Model_of_Best_Fit"
colnames(model_scoring) <- column_names

model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 0] <- "Natural"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 1] <- "Cubic"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 2] <- "Either"


R2_plot <- ggplot(data = model_scoring, aes(x = Best_Fit, fill = Model_of_Best_Fit)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")

AIC_plot <- ggplot(data = model_scoring, aes(x = Preferred_Model, fill = Preferred_Model_Name)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")

grid.arrange(R2_plot, AIC_plot, ncol = 1)

name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(rgb_colors_names == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- rgb_colors[c(position_vector)]


title_for_legend <- "Species"

ggplot(data = model_scoring, aes(x = Natural_AIC, y = Cubic_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 1) + xlab("Natural AIC Score") + ylab("Cubic AIC Score") + ggtitle("AIC Scores", subtitle = "Cubic vs. Natural Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

ggplot(data = model_scoring, aes(x = Natural_Adj_R2, y = Cubic_Adj_R2)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 1) + xlab("Natural R^2 Score") + ylab("Cubic R^2 Score") + ggtitle("R^2 Scores", subtitle = "Cubic vs. Natural Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))



```


## AIC and R^2 distributions (ns vs. bs)


```{r}

row_extraction <- seq(from = 5, to = 2055, by = 41)


model_scoring <- spline_table_df_ordered[row_extraction, c(1,2,6,7,9,10)]

# verifying that the df are all the same
print(unique(model_scoring$df))

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model = min(c(Natural_AIC, b_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,7] == model_scoring[i,5]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,7] == model_scoring[i,6]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,7] == model_scoring[i,5] & model_scoring[i,7] == model_scoring[i,6]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[8] <- "Preferred_Model_Name"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 0] <- "Natural"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 1] <- "Basis"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 2] <- "Either"



model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Best_Fit = max(c(Natural_Adj_R2, b_Adj_R2)))

best_fit_model <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,9] == model_scoring[i,3]){
    best_fit_model[i] <- 0
  }
  else if (model_scoring[i,9] == model_scoring[i,4]){
    best_fit_model[i] <- 1
  }
  else if (model_scoring[i,9] == model_scoring[i,3] & model_scoring[i,4] == model_scoring[i,9]){
    best_fit_model[i] <- 2
  }
    }


model_scoring <- cbind(model_scoring, best_fit_model)
column_names <- colnames(model_scoring)
column_names[10] <- "Model_of_Best_Fit"
colnames(model_scoring) <- column_names

model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 0] <- "Natural"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 1] <- "Basis"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 2] <- "Either"


R2_plot <- ggplot(data = model_scoring, aes(x = Best_Fit, fill = Model_of_Best_Fit)) + geom_histogram() + scale_fill_brewer(palette = "Spectral") + xlab("R^2 Value") + ylab("Frequency")

AIC_plot <- ggplot(data = model_scoring, aes(x = Preferred_Model, fill = Preferred_Model_Name)) + geom_histogram() + scale_fill_brewer(palette = "Spectral") + xlab("AIC Score") + ylab("Frequency")

grid.arrange(R2_plot, AIC_plot, ncol = 1)

name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(rgb_colors_names == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- rgb_colors[c(position_vector)]


title_for_legend <- "Species"

ggplot(data = model_scoring, aes(x = Natural_AIC, y = b_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 1) + xlab("Natural AIC Score") + ylab("Basis AIC Score") + ggtitle("AIC Scores", subtitle = "Basis vs. Natural Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

ggplot(data = model_scoring, aes(x = Natural_Adj_R2, y = b_Adj_R2)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 1) + xlab("Natural R^2 Score") + ylab("Basis R^2 Score") + ggtitle("R^2 Scores", subtitle = "Basis vs. Natural Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))

```






# Log-Transformed fits of data (knots = 7)
```{r, warning=FALSE, message=FALSE}

library(nlme)

load(file = "quick_reload.RData")

  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 10 degrees of freedom
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 10), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 10 degrees of freedom
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 10), correlation
                                            = corAR1(form = ~ 1))
    
    basis_spline_data <- bs(wl, df = 10)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  # Remove all values below 350 nm
  # This is to remove any values less than 1 to avoid Inf/NaN errors during 
  # log-transformation
  # Also, this only remove UV values from the dataset
  tanData_filtered <- tanData_filtered[-c(1:51),]

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })


  plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Splines for Reflectance
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Splines for log Reflectance
plot(wl, log(reflectance), type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Log Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$log_reflectance_AIC, 3), "BIC:", round(result$log_reflectance_BIC, 2), "logLik:", round(result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
  }
  
# Generates the side-by-side plots for each species
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

# Creates a pdf of the side-by-side plots
pdf("reflectance_vs_log_reflectance_with_metrics_7knots.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()



# Creating a data table for all of the model scores, colors of each species, and knot placements

spline_table <- data.frame(
  Species = names(spline_results),
  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results, function(x) round(x$log_reflectance_AIC, 2)),  
  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results, function(x) round(x$log_reflectance_BIC, 2)),
  Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results, function(x) round(x$log_reflectance_logLik, 2)),
  Degree = sapply(spline_results, function(x) c(x$degree)),
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


Internal_Knots = sapply(spline_results, function(x) c(x$internal_knots))
Internal_Knots <- t(Internal_Knots)

name_vector <- NULL
Internal_Knots_names <- NULL
for (i in 1:dim(Internal_Knots)[2]){

name_vector <- c(paste("Internal_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Internal_Knots_names <- rbind(Internal_Knots_names, name_vector)
}
colnames(Internal_Knots) <- Internal_Knots_names

Boundary_Knots = sapply(spline_results, function(x) c(x$boundary_knots))
Boundary_Knots <- t(Boundary_Knots)
name_vector <- NULL
Boundary_Knots_names <- NULL
for (i in 1:dim(Boundary_Knots)[2]){

name_vector <- c(paste("Boundary_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Boundary_Knots_names <- rbind(Boundary_Knots_names, name_vector)
}
colnames(Boundary_Knots) <- Boundary_Knots_names


spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Boundary_Knots)


# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)



pdf("spline_summary_table_reflect_and_logreflect_knots7.pdf", width = 30, height = 20)
grid.newpage()
grid.table(spline_table[,1:10], rows = NULL)
grid.newpage()
grid.table(spline_table[,11:20], rows = NULL)
dev.off()

```


# Model scores of reflectance and log reflectance
```{r}


# What model is preferred using AIC Scores

model_scoring <- spline_table[,c(1,4:9)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_AIC = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[9] <- "Preferred_Model_Name_AIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 2] <- "Either"


# What model is preferred using BIC Scores


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_BIC = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,10] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,10] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,10] == model_scoring[i,4] & model_scoring[i,5] == model_scoring[i,10]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[11] <- "Preferred_Model_Name_BIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 2] <- "Either"


# What model is preferred using logLik Scores


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_logLik = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,12] == model_scoring[i,6]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,12] == model_scoring[i,7]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,12] == model_scoring[i,6] & model_scoring[i,7] == model_scoring[i,12]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[13] <- "Preferred_Model_Name_logLik"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 2] <- "Either"

```


# Plots of model scores

```{r}

name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(model_scoring$Species == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- spline_table[c(position_vector),11]
names(tanager_subset_colors) <- spline_table$Species

title_for_legend <- "Species"


# AIC scores
ggplot(data = model_scoring, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance AIC Score") + ylab("Log Reflectance AIC Score") + ggtitle("AIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# BIC scores
ggplot(data = model_scoring, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance BIC Score") + ylab("Log Reflectance BIC Score") + ggtitle("BIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# logLik scores
ggplot(data = model_scoring, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance logLik Score") + ylab("Log_Reflectance logLik Score") + ggtitle("logLik Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))

```






# Knots = 15

```{r, warning=FALSE, message = FALSE}
  
load("quick_reload.RData")
  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 10 degrees of freedom
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 18), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 10 degrees of freedom
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 18), correlation
                                            = corAR1(form = ~ 1))
    
    basis_spline_data <- bs(wl, df = 18)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  # Remove all values below 350 nm
  # This is to remove any values less than 1 to avoid Inf/NaN errors during 
  # log-transformation
  # Also, this only remove UV values from the dataset
  tanData_filtered <- tanData_filtered[-c(1:51),]

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })


  plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Splines for Reflectance
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Splines for log Reflectance
plot(wl, log(reflectance), type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Log Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$log_reflectance_AIC, 3), "BIC:", round(result$log_reflectance_BIC, 2), "logLik:", round(result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
  }
  
# Generates the side-by-side plots for each species
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

# Creates a pdf of the side-by-side plots
pdf("reflectance_vs_log_reflectance_with_metrics_15knots.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()



# Creating a data table for all of the model scores, colors of each species, and knot placements

spline_table <- data.frame(
  Species = names(spline_results),
  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results, function(x) round(x$log_reflectance_AIC, 2)),  
  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results, function(x) round(x$log_reflectance_BIC, 2)),
  Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results, function(x) round(x$log_reflectance_logLik, 2)),
  Degree = sapply(spline_results, function(x) c(x$degree)),
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


Internal_Knots = sapply(spline_results, function(x) c(x$internal_knots))
Internal_Knots <- t(Internal_Knots)

name_vector <- NULL
Internal_Knots_names <- NULL
for (i in 1:dim(Internal_Knots)[2]){

name_vector <- c(paste("Internal_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Internal_Knots_names <- rbind(Internal_Knots_names, name_vector)
}
colnames(Internal_Knots) <- Internal_Knots_names

Boundary_Knots = sapply(spline_results, function(x) c(x$boundary_knots))
Boundary_Knots <- t(Boundary_Knots)
name_vector <- NULL
Boundary_Knots_names <- NULL
for (i in 1:dim(Boundary_Knots)[2]){

name_vector <- c(paste("Boundary_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Boundary_Knots_names <- rbind(Boundary_Knots_names, name_vector)
}
colnames(Boundary_Knots) <- Boundary_Knots_names


spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Boundary_Knots)


# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)



pdf("spline_summary_table_reflect_and_logreflect_knots15.pdf", width = 30, height = 20)
grid.newpage()
grid.table(spline_table[,1:10], rows = NULL)
grid.newpage()
grid.table(spline_table[,11:20], rows = NULL)
dev.off()


model_scoring <- spline_table[,c(1,4:9)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_AIC = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[9] <- "Preferred_Model_Name_AIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_BIC = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,10] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,10] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,10] == model_scoring[i,4] & model_scoring[i,5] == model_scoring[i,10]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[11] <- "Preferred_Model_Name_BIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_logLik = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,12] == model_scoring[i,6]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,12] == model_scoring[i,7]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,12] == model_scoring[i,6] & model_scoring[i,7] == model_scoring[i,12]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[13] <- "Preferred_Model_Name_logLik"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 2] <- "Either"


name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(model_scoring$Species == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- spline_table[c(position_vector),11]
names(tanager_subset_colors) <- spline_table$Species

title_for_legend <- "Species"


# AIC scores
ggplot(data = model_scoring, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance AIC Score") + ylab("Log Reflectance AIC Score") + ggtitle("AIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# BIC scores
ggplot(data = model_scoring, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance BIC Score") + ylab("Log Reflectance BIC Score") + ggtitle("BIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# logLik scores
ggplot(data = model_scoring, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance logLik Score") + ylab("Log_Reflectance logLik Score") + ggtitle("logLik Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
```





# Knots = 20

```{r, warning=FALSE, message = FALSE}

load(file = "quick_reload.RData")
  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 23 degrees of freedom
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 23), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 10 degrees of freedom
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 23), correlation
                                            = corAR1(form = ~ 1))
    
    basis_spline_data <- bs(wl, df = 23)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  # Remove all values below 350 nm
  # This is to remove any values less than 1 to avoid Inf/NaN errors during 
  # log-transformation
  # Also, this only remove UV values from the dataset
  tanData_filtered <- tanData_filtered[-c(1:51),]

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })


  plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Splines for Reflectance
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Splines for log Reflectance
plot(wl, log(reflectance), type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Log Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$log_reflectance_AIC, 3), "BIC:", round(result$log_reflectance_BIC, 2), "logLik:", round(result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
  }
  
# Generates the side-by-side plots for each species
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

# Creates a pdf of the side-by-side plots
pdf("reflectance_vs_log_reflectance_with_metrics_20knots.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()



# Creating a data table for all of the model scores, colors of each species, and knot placements

spline_table <- data.frame(
  Species = names(spline_results),
  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results, function(x) round(x$log_reflectance_AIC, 2)),  
  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results, function(x) round(x$log_reflectance_BIC, 2)),
  Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results, function(x) round(x$log_reflectance_logLik, 2)),
  Degree = sapply(spline_results, function(x) c(x$degree)),
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


Internal_Knots = sapply(spline_results, function(x) c(x$internal_knots))
Internal_Knots <- t(Internal_Knots)

name_vector <- NULL
Internal_Knots_names <- NULL
for (i in 1:dim(Internal_Knots)[2]){

name_vector <- c(paste("Internal_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Internal_Knots_names <- rbind(Internal_Knots_names, name_vector)
}
colnames(Internal_Knots) <- Internal_Knots_names

Boundary_Knots = sapply(spline_results, function(x) c(x$boundary_knots))
Boundary_Knots <- t(Boundary_Knots)
name_vector <- NULL
Boundary_Knots_names <- NULL
for (i in 1:dim(Boundary_Knots)[2]){

name_vector <- c(paste("Boundary_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Boundary_Knots_names <- rbind(Boundary_Knots_names, name_vector)
}
colnames(Boundary_Knots) <- Boundary_Knots_names


spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Boundary_Knots)


# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)



pdf("spline_summary_table_reflect_and_logreflect_knots20.pdf", width = 30, height = 20)
grid.newpage()
grid.table(spline_table[,1:10], rows = NULL)
grid.newpage()
grid.table(spline_table[,11:20], rows = NULL)
grid.newpage()
grid.table(spline_table[,21,28], rows = NULL)
dev.off()


model_scoring <- spline_table[,c(1,4:9)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_AIC = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[9] <- "Preferred_Model_Name_AIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_BIC = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,10] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,10] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,10] == model_scoring[i,4] & model_scoring[i,5] == model_scoring[i,10]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[11] <- "Preferred_Model_Name_BIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_logLik = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,12] == model_scoring[i,6]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,12] == model_scoring[i,7]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,12] == model_scoring[i,6] & model_scoring[i,7] == model_scoring[i,12]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[13] <- "Preferred_Model_Name_logLik"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 2] <- "Either"


name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(model_scoring$Species == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- spline_table[c(position_vector),11]
names(tanager_subset_colors) <- spline_table$Species

title_for_legend <- "Species"


# AIC scores
ggplot(data = model_scoring, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance AIC Score") + ylab("Log Reflectance AIC Score") + ggtitle("AIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# BIC scores
ggplot(data = model_scoring, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance BIC Score") + ylab("Log Reflectance BIC Score") + ggtitle("BIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# logLik scores
ggplot(data = model_scoring, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance logLik Score") + ylab("Log_Reflectance logLik Score") + ggtitle("logLik Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
```




# Knots = 40

```{r, warning=FALSE, message = FALSE}

load(file = "quick_reload.RData")
  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 43 degrees of freedom
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 43), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 10 degrees of freedom
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 43), correlation
                                            = corAR1(form = ~ 1))
    
    basis_spline_data <- bs(wl, df = 43)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  # Remove all values below 350 nm
  # This is to remove any values less than 1 to avoid Inf/NaN errors during 
  # log-transformation
  # Also, this only remove UV values from the dataset
  tanData_filtered <- tanData_filtered[-c(1:51),]

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })


  plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Splines for Reflectance
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Splines for log Reflectance
plot(wl, log(reflectance), type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Log Reflectance -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$log_reflectance_AIC, 3), "BIC:", round(result$log_reflectance_BIC, 2), "logLik:", round(result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
  }
  
# Generates the side-by-side plots for each species
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

# Creates a pdf of the side-by-side plots
pdf("reflectance_vs_log_reflectance_with_metrics_40knots.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()



# Creating a data table for all of the model scores, colors of each species, and knot placements

spline_table <- data.frame(
  Species = names(spline_results),
  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results, function(x) round(x$log_reflectance_AIC, 2)),  
  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results, function(x) round(x$log_reflectance_BIC, 2)),
  Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results, function(x) round(x$log_reflectance_logLik, 2)),
  Degree = sapply(spline_results, function(x) c(x$degree)),
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


Internal_Knots = sapply(spline_results, function(x) c(x$internal_knots))
Internal_Knots <- t(Internal_Knots)

name_vector <- NULL
Internal_Knots_names <- NULL
for (i in 1:dim(Internal_Knots)[2]){

name_vector <- c(paste("Internal_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Internal_Knots_names <- rbind(Internal_Knots_names, name_vector)
}
colnames(Internal_Knots) <- Internal_Knots_names

Boundary_Knots = sapply(spline_results, function(x) c(x$boundary_knots))
Boundary_Knots <- t(Boundary_Knots)
name_vector <- NULL
Boundary_Knots_names <- NULL
for (i in 1:dim(Boundary_Knots)[2]){

name_vector <- c(paste("Boundary_knot_"))
number_vector <- paste(i)
name_vector <- paste(name_vector, number_vector, sep = '')
Boundary_Knots_names <- rbind(Boundary_Knots_names, name_vector)
}
colnames(Boundary_Knots) <- Boundary_Knots_names


spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Boundary_Knots)


# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)



pdf("spline_summary_table_reflect_and_logreflect_knots40.pdf", width = 30, height = 20)
grid.newpage()
grid.table(spline_table[,1:10], rows = NULL)
grid.newpage()
grid.table(spline_table[,11:20], rows = NULL)
dev.off()


model_scoring <- spline_table[,c(1,4:9)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_AIC = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[9] <- "Preferred_Model_Name_AIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_AIC[model_scoring$Preferred_Model_Name_AIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_BIC = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,10] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,10] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,10] == model_scoring[i,4] & model_scoring[i,5] == model_scoring[i,10]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[11] <- "Preferred_Model_Name_BIC"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_BIC[model_scoring$Preferred_Model_Name_BIC == 2] <- "Either"


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model_logLik = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,12] == model_scoring[i,6]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,12] == model_scoring[i,7]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,12] == model_scoring[i,6] & model_scoring[i,7] == model_scoring[i,12]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[13] <- "Preferred_Model_Name_logLik"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 0] <- "Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 1] <- "Log Reflectance"
model_scoring$Preferred_Model_Name_logLik[model_scoring$Preferred_Model_Name_logLik == 2] <- "Either"


name_vector <- NULL
position <- NULL
position_vector <- NULL

for (species_name in names(spline_results)){
  name_vector <- as.character(species_name)
  position <- (which(model_scoring$Species == name_vector))
  position_vector <- rbind(position_vector, position)
}

tanager_subset_colors <- spline_table[c(position_vector),11]
names(tanager_subset_colors) <- spline_table$Species

title_for_legend <- "Species"


# AIC scores
ggplot(data = model_scoring, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance AIC Score") + ylab("Log Reflectance AIC Score") + ggtitle("AIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# BIC scores
ggplot(data = model_scoring, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance BIC Score") + ylab("Log Reflectance BIC Score") + ggtitle("BIC Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))

# logLik scores
ggplot(data = model_scoring, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors))) + theme(legend.key.size = unit(0.5, "cm")) + geom_abline(intercept = 0, slope = 3) + xlab("Reflectance logLik Score") + ylab("Log_Reflectance logLik Score") + ggtitle("logLik Scores", subtitle = "Reflectance vs. Log Reflectance Splines") + scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
```


# Ideal Knot Number Based on Model Score

```{r, message=FALSE, warning=FALSE}

# Model Scores slightly punished for adding more knots, but log-transforming data has better model
# scores for every number of knots
# I will leave the code here in case we need the scores for a specific knot number in the future.

# Setup -------------------------------------------------------------------

load(file = "quick_reload.RData")
library(nlme)

# Remove all values below 350 nm
# This is to remove any values less than 1 to avoid Inf/NaN errors during 
# log-transformation
# Also, this only remove UV values from the dataset
tanData_filtered <- tanData_filtered[-c(1:51),]

species_vector <- names(tanData_filtered[-1])
names(species_vector) <- species_vector

reflectance_AIC_scores <- NULL
reflectance_BIC_scores <- NULL
reflectance_logLik_scores <- NULL

log_reflectance_AIC_scores <- NULL
log_reflectance_BIC_scores <- NULL
log_reflectance_logLik_scores <- NULL



AIC_reflectance_varying_knots <- rep(NA, 51)
BIC_reflectance_varying_knots <- rep(NA, 51)
logLik_reflectance_varying_knots <- rep(NA, 51)
AIC_log_reflectance_varying_knots <- rep(NA, 51)
BIC_log_reflectance_varying_knots <- rep(NA, 51)
logLik_log_reflectance_varying_knots <- rep(NA, 51)


# 1 knot ------------------------------------------------------------------


# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 4)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 4))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 2 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 5)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 5))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 3 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 6)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 6))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 4 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 7)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 7))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 5 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 8)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 8))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 6 Knots -----------------------------------------------------------------
# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 9)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 9))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 7 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 10)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 10))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 8 Knots -----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 11)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 11))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 9 Knots -----------------------------------------------------------------
# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 12)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 12))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


# 10 Knots ----------------------------------------------------------------


# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 13)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 13))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)
# 11 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 14)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 14))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 12 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 15)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 15))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 13 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 16)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 16))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 14 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 17)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 17))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 15 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 18)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 18))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 16 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 19)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 19))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 17 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 20)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 20))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 18 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 21)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 21))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 19 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 22)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 22))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 20 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 23)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 23))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 21 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 24)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 24))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 22 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 25)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 25))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 23 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 26)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 26))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 24 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 27)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 27))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 25 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 28)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 28))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 26 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 29)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 29))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 27 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 30)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 30))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 28 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 31)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 31))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 29 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 32)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 32))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 30 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 33)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 33))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 31 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 34)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 34))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 32 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 35)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 35))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 33 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 36)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 36))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 34 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 37)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 37))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 35 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 38)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 38))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 36 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 39)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 39))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 37 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 40)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 40))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 38 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 41)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 41))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 39 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 42)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 42))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)

# 40 Knots ----------------------------------------------------------------

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
fit_splines_ideal_knots <- function(wl, reflectance) {
  # Fit cubic splines to base reflectance data with 4 degrees of freedom
  cubic_spline_fit_reflectance <- gls(reflectance ~ (bs(wl, df = 43)), correlation = 
                                        corAR1(form = ~ 1))
  
  # Fit cubic spline to log-transformed reflectance values with 4 degrees of freedom
  cubic_spline_fit_log_reflectance <- gls((log(reflectance) ~ (bs(wl, df = 43))), correlation
                                          = corAR1(form = ~ 1))
  
  
  
  
  # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
  reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
  log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
  
  reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
  log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
  
  reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
  log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik
  
  # Extracts rspec and rgb values from the reflectance curves
  reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                             predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  reflectance_rgb <- spec2rgb(reflectance_rspec)
  
  log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                                                 predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
  log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
  
  return(list(
    reflectance_spline_fit = cubic_spline_fit_reflectance,
    log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
    reflectance_AIC = reflectance_AIC,
    log_reflectance_AIC = log_reflectance_AIC,
    reflectance_BIC = reflectance_BIC,
    log_reflectance_BIC = log_reflectance_BIC,
    reflectance_logLik = reflectance_logLik,
    log_reflectance_logLik = log_reflectance_logLik,
    reflectance_rgb = reflectance_rgb,
    log_reflectance_rgb = log_reflectance_rgb
  ))
}
# End of function


# Apply function to each species

spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines_ideal_knots(tanData_filtered$wl, reflectance)
})


for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  x <- spline_results[[name_vector]]
  y <- which(name_vector == names(species_vector))
  
  
  reflectance_AIC_scores[y] <- x$reflectance_AIC
  reflectance_BIC_scores[y] <- x$reflectance_BIC
  reflectance_logLik_scores[y] <- x$reflectance_logLik
  log_reflectance_AIC_scores[y] <- x$log_reflectance_AIC
  log_reflectance_BIC_scores[y] <- x$log_reflectance_BIC
  log_reflectance_logLik_scores[y] <- x$log_reflectance_logLik
}
AIC_reflectance_varying_knots <- cbind(AIC_reflectance_varying_knots, reflectance_AIC_scores)
BIC_reflectance_varying_knots <- cbind(BIC_reflectance_varying_knots, reflectance_BIC_scores)
logLik_reflectance_varying_knots <- cbind(logLik_reflectance_varying_knots, reflectance_logLik_scores)

AIC_log_reflectance_varying_knots <- cbind(AIC_log_reflectance_varying_knots,log_reflectance_AIC_scores)
BIC_log_reflectance_varying_knots <- cbind(BIC_log_reflectance_varying_knots,log_reflectance_BIC_scores)
logLik_log_reflectance_varying_knots <- cbind(logLik_log_reflectance_varying_knots,log_reflectance_logLik_scores)


```


```

rm(list = setdiff(ls(), c("AIC_reflectance_varying_knots", "AIC_log_reflectance_varying_knots", "BIC_log_reflectance_varying_knots", "BIC_reflectance_varying_knots", "logLik_log_reflectance_varying_knots", "logLik_reflectance_varying_knots")))

save.image(file = "Varying_knots_dataframes.RData")

```

# Table for Model Scores with Different Knot Count

```{r}

load(file = "Varying_knots_dataframes.RData")

AIC_reflectance_varying_knots <- AIC_reflectance_varying_knots[,2:41]
AIC_log_reflectance_varying_knots <- AIC_log_reflectance_varying_knots[,2:41]
BIC_reflectance_varying_knots <- BIC_reflectance_varying_knots[,2:41]
BIC_log_reflectance_varying_knots <- BIC_log_reflectance_varying_knots[,2:41]
logLik_reflectance_varying_knots <- logLik_reflectance_varying_knots[,2:41]
logLik_log_reflectance_varying_knots <- logLik_log_reflectance_varying_knots[,2:41]

rownames(AIC_reflectance_varying_knots) <- names(tanData_filtered[-1])
rownames(AIC_log_reflectance_varying_knots) <- names(tanData_filtered[-1])
rownames(BIC_reflectance_varying_knots) <- names(tanData_filtered[-1])
rownames(BIC_log_reflectance_varying_knots) <- names(tanData_filtered[-1])
rownames(logLik_reflectance_varying_knots) <- names(tanData_filtered[-1])
rownames(logLik_log_reflectance_varying_knots) <- names(tanData_filtered[-1])


columnnames <- rep(NA, 40)
for (i in 1:40){
  name_vector <- c(paste(".Knots"))
  number_vector <- paste(i)
  name_vector <- paste(number_vector, name_vector, sep = '')
  columnnames[i] <- name_vector
}

columnnames[1] <- "1.Knot"


colnames(AIC_reflectance_varying_knots) <- columnnames
colnames(AIC_log_reflectance_varying_knots) <- columnnames
colnames(BIC_reflectance_varying_knots) <- columnnames
colnames(BIC_log_reflectance_varying_knots) <- columnnames
colnames(logLik_reflectance_varying_knots) <- columnnames
colnames(logLik_log_reflectance_varying_knots) <- columnnames



species_names_heatmap <- NA
for (species_name in names(tanData_filtered[-1])){
species_names <- rep(species_name, 40)
species_names_heatmap <- rbind(species_names_heatmap, species_names)
}

species_names_heatmap <- species_names_heatmap[2:52,]
species_names_heatmap <- t(species_names_heatmap)
species_names_heatmap <- c(species_names_heatmap)


knot_counts_heatmap <- NA
for (i in 1:40){
knot_counts <- as.character(i)
knot_name <- paste("Knot.")
knot_count <- paste(knot_name, knot_counts, sep = )
knot_counts_heatmap <- rbind(knot_counts_heatmap, knot_counts)
}
knot_counts_heatmap <- c(knot_counts_heatmap)
knot_counts_heatmap <- na.omit(knot_counts_heatmap)
knot_counts_heatmap <- rep(knot_counts_heatmap, 51)

length(species_names_heatmap) ==  length(knot_counts_heatmap)

AIC_reflectance_varying_knots <- t(AIC_reflectance_varying_knots)
data <- c(AIC_reflectance_varying_knots)

length(species_names_heatmap) ==  length(data)
length(knot_counts_heatmap) == length(data)


knot_counts_heatmap <- rep(c(LETTERS, "Z1", "Z2","Z3","Z4","Z5","Z6","Z7","Z8","Z9","Z91","Z92","Z93","Z94", "Z95"),51)


heatmap <- NA
heatmap <- cbind(species_names_heatmap, knot_counts_heatmap)
heatmap <- cbind(heatmap, data)
heatmap <- data.frame(heatmap)
heatmap$knot_counts_heatmap <- as.numeric(heatmap$knot_counts_heatmap)
heatmap$data <- as.numeric(heatmap$data)
 
# Heatmap 
ggplot(data = heatmap, aes(y = species_names_heatmap, x = knot_counts_heatmap, fill= data)) + geom_tile(show.legend = TRUE)





```




```{message = FALSE}

# output from aictab

#   K    AICc Delta_AICc AICcWt Cum.Wt Res.LL
# z 26 -576.00       0.00   0.76   0.76 316.17
# y 27 -573.71       2.29   0.24   1.00 316.20

# AIC function output
                             df        AIC
#x$reflectance_spline_fit     21  -589.9725
# x$log_reflectance_spline_fit 21 -1852.1826

                             df        AIC
# x$reflectance_spline_fit     26  -580.3436
# x$log_reflectance_spline_fit 26 -1823.3606

```



# Binning Reflectance data

```{r, warning=FALSE, message=FALSE}

#loading in Tanager dataset

load("quick_reload.RData")
library(nlme)

 # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 10 degrees of freedom
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 38), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 10 degrees of freedom
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  # Remove all values below 350 nm
  # This is to remove any values less than 1 to avoid Inf/NaN errors during 
  # log-transformation
  # Also, this only remove UV values from the dataset
  tanData_filtered <- tanData_filtered[-c(1:51),]

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })



  
# Summary stats at each wl

tanData_filtered_wowl <- tanData_filtered[-1]
tanData_filtered_wowl <- t(tanData_filtered_wowl)

wl_bins <- seq(1, 350, 10)

wl_mean <- rep(NA, 35)
wl_var <- rep(NA, 35)
wl_sd <- rep(NA, 35)
wl_data <- NULL
wl_dataframe <- NA


for (i in 1:35){
  wl_range <- seq(wl_bins[i],(wl_bins[i])+9, 1)
  print(wl_range)

  wl_mean[i] <- mean(tanData_filtered_wowl[,wl_range])
  wl_var[i] <- var(tanData_filtered_wowl[,wl_range])
  wl_sd[i] <- sd(tanData_filtered_wowl[, wl_range])

  wl_data <- c(tanData_filtered_wowl[,wl_range])

  wl_dataframe <- rbind(wl_dataframe, wl_data)

  # Verifying that for loop worked
  test_mean <- (c(tanData_filtered_wowl[,wl_range]))
  print(mean(test_mean) == wl_mean[i])
}

wl_summary_stats <- cbind(wl_mean, wl_var)
wl_summary_stats <- cbind(wl_summary_stats, wl_sd)

wl_ranges <- c("351-360", "361-370","371-380","381-390","391-400","401-410","411-420","421-430","431-440","441-450","451-460","461-470","471-480","481-490","491-400","501-510","511-520","521-530","531-540", "541-550","551-560","561-570","571-580","581-590","591-500","601-610","611-620","621-630","631-640","641-650","651-660","661-670","671-680","681-690","691-700")
rownames(wl_summary_stats) <- wl_ranges

wl_dataframe <- wl_dataframe[2:36,]
rownames(wl_dataframe) <- wl_ranges
wl_dataframe <- t(wl_dataframe)




colors_for_plots <- c(rep("violet", 10), rep("blue",5), rep("green", 7), rep("yellow", 2), rep("orange", 3), rep("red", 8))
boxplot(x = wl_dataframe[,1:35], col = colors_for_plots)

barplot(height = wl_mean, names.arg = wl_ranges, cex.names = 0.65, col = colors_for_plots)
barplot(height = wl_sd, names.arg = wl_ranges, cex.names = 0.65, col = colors_for_plots)
barplot(height = wl_var, names.arg = wl_ranges, cex.names = 0.65, col = colors_for_plots)



spline_coef_data <- NA

for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  spline_coefficients <- spline_results[[name_vector]]
  
  spline_coefficients <- spline_coefficients$reflectance_coef
  
  spline_coef_data <- rbind(spline_coef_data, spline_coefficients)
  
  
}


spline_coef_data <- spline_coef_data[-1,]
spline_coef_data <- data.frame(spline_coef_data)
rownames(spline_coef_data) <- names(spline_results)
species <- as.character(names(spline_results))
spline_coef_data <- cbind(species, spline_coef_data)

coefficient_names <- c("Species", "Intercept", "Coefficient.1","Coefficient.2","Coefficient.3","Coefficient.4","Coefficient.5","Coefficient.6","Coefficient.7","Coefficient.8","Coefficient.9","Coefficient.10","Coefficient.11","Coefficient.12","Coefficient.13","Coefficient.14","Coefficient.15","Coefficient.16","Coefficient.17","Coefficient.18","Coefficient.19","Coefficient.20","Coefficient.21","Coefficient.22","Coefficient.23","Coefficient.24","Coefficient.25","Coefficient.26","Coefficient.27","Coefficient.28","Coefficient.29","Coefficient.30","Coefficient.31","Coefficient.32","Coefficient.33","Coefficient.34","Coefficient.35","Coefficient.36","Coefficient.37","Coefficient.38")

colnames(spline_coef_data) <- coefficient_names



write_tsv(spline_coef_data, file = "spline_coefficients_BEAST.txt")

```

```{r}
# Spline Coefficient Diffusion Rates


knot_counts_heatmap <- NA
for (i in 1:40){
knot_counts <- as.character(i)
knot_name <- paste("Knot.")
knot_count <- paste(knot_name, knot_counts, sep = )
knot_counts_heatmap <- rbind(knot_counts_heatmap, knot_counts)
}


rownames_vector <- c(diffusion_rate_data[,1])
rownames(diffusion_rate_data) <- rownames_vector

columnnames_vector <- c(diffusion_rate_data[1,])
colnames(diffusion_rate_data) <- columnnames_vector


diffusion_rate_data <- diffusion_rate_data[-1,-1]


diffusion_rate_data <- diffusion_rate_data[,c(1,38,36,34,32,30,28,26,24,3,15,13,19,17,8,6,11,10,22,21,23,35,33,39,37,27,25,31,29,2,5,4,16,14,20,18,9,7,12)]

diffusion_rate_data <- t(diffusion_rate_data)
diffusion_rate_data <- data.frame(diffusion_rate_data)

diffusion_rate_data$mean <- as.numeric(diffusion_rate_data$mean)

rownames(diffusion_rate_data) <- c("Intercept", 1:38)
barplot(height = diffusion_rate_data$mean, names.arg = rownames(diffusion_rate_data), main)


```





```{r}
# Can be taken from any species as knot placements are identical
internal_knots_placement <- spline_results[["TanCyo"]]$internal_knots
print(internal_knots_placement)
length(internal_knots_placement)

for (i in 1:35){
  print(internal_knots_placement[i+1] - internal_knots_placement[i])
  
}


```
