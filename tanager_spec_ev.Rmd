---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---

### Libraries
```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(nlme)
library(splines2)
library(evobiR)
library(mvMORPH)
library(readxl)
library(png)
source("annotatedTreeReader.R")
```


### Step 1: Loading Reflectance Data

```{r}


suppressMessages({
  # File pathway linking to the reflectance data for Thraupidae specimens on laptop
  ddPath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\RefDataSpeciesSummary_MatchingMF\\data"
  
  # File pathway linking to the reflectance data for Thraupidae specimens on PC
  # ddPath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\RefDataSpeciesSummary_MatchingMF"

  # Reads in all of .csv files
  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  # Extracts all of the wavelengths and turns it into a vector
  wl <- dat[[1]][, 1]
  # Removes the wavelength column from each of the species' data frames
  dat <- sapply(dat, "[", -1)
  
  # Takes the reflectance data from each patch available for each species 
  # Combines reflectance data with wavelength vector ranging from 300-700 nm
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  # Turns all negative reflectance values in data frame to 0
  specs <- procspec(specs, fixneg="zero")
  
  # Creates a data frame with just male specimens
  male_specs <- specs %>% select(!ends_with("f"))
  
  # Creates a data frame from the male specimen data frame using only 
  # the crown patch of the bird
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  # Finds the rgb hex code for each of the crown patches
  rgb_colors <- spec2rgb(crown_data)
  # Adds names of the species to each hex color code
  names(rgb_colors) <- names(crown_data)[-1]
  
  # Verifies that data frame has been created correctly
  head(crown_data)
})


```



### Step 2: Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}

# File pathway linking to the Thraupidae tree on laptop
treepath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# File pathway linking to the Thraupidae tree on PC
# treepath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# Reads Thraupidae tree into R
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)

# Creates a NEXUS tree file into working directory
write.nexus(tanagerTree, file = "tanagerTree.NEXUS")
```



### Step 3: Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify data frame created correctly
head(tanData_filtered)

# Verifies that there are 0 species in data frame that should not be there
(names(tanData_filtered[-1]) == tanager_species)

# Verifies that there are not any species have not been added to data frame
length(names(tanData_filtered[-1])) == length(tanager_species)


```



### Step 4: Fitting Cubic Splines to the Tanager Reflectance and Log-Transformed Reflectance Data

Website that explains what splines are: 
https://community.jmp.com/t5/JMPer-Cable/Understanding-cubic-splines/ba-p/39511

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Cubic Splines to Tanager reflectance data

 # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 38 degrees of freedom (35 knots)
    # We use gls instead of lm, as our error structure fails the independence assumption
    # corAR1 was the error structure recommended for us to use
    # When using the corAR1 function, the argument value pertains to the type of autocorrelation present in the
    # corAR1 autocorrelation structure (at any given point, we only care about the autocorrelation of the next
    # surrounding point {x, x+1}).
    # For corAR1, I leave the 'value' argument at 0, given that it does not change any of the coefficient values
    # or the model score values. I will note that the error structure performs better (+ values) 
    # and worse (- values) at non-zero values, although I am unsure if this has any noteworthy
    # benefits to optimize. I need to talk to Professor Marc Suchard to clarify if leaving
    # it at the default of zero is acceptable.
    # With the form argument, I used form = ~ 1, form = ~ 300:700, and form = ~ wl,
    # and each produced identical results, so I will stick with the default of 
    # form = ~ 1 unless told otherwise.
    # For the final argument ('fixed'), fixed = TRUE produces lower residual standard
    # error values, but the model score performs lower than when fixed = FALSE.
    # I think this another question that needs to be asked as to which is better,
    # but for now, I will keep the default as fixed = FALSE.
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 38), correlation = 
                                          corAR1(form = ~ 1))

    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    # It is important to note that when working with trait data, we want to 
    # use the same basis matrix to preserve the same "trait space" (need to clarify
    # if this the correct thinking) between species. Thus, we make sure to keep the
    # same range of wavelength when proceeding forward (300-700 nm).
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC

    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC

    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      reflectance_coef = reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines_log <- function(wl, reflectance) {

    # Fit cubic spline to log-transformed reflectance values with 38 degrees of freedom (35 knots)
    cubic_spline_fit_log_reflectance <- gls((reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC

    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_log_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      log_reflectance_coef = log_reflectance_coef,
      log_reflectance_AIC = log_reflectance_AIC,
      log_reflectance_BIC = log_reflectance_BIC,
      log_reflectance_logLik = log_reflectance_logLik,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  
  # Here we need to make a separate data frame for our log-transformed data
  # This is to convert any values less than 1 to 1 to avoid Inf/NaN errors during 
  # our log-transformation of the reflectance data

  # Creates a separate data frame for only log-transformed data
  tanlogData_filtered <- tanData_filtered
  
  # Nested for loop to turn all data points < 1 into 1 to prevent any Inf/NaN errors
  for (i in 2:52){
    y <- as.numeric(i)
    for (j in 1:401){
      x <- as.numeric(j)
      matrix_position <- tanlogData_filtered[x,y]
      if (tanlogData_filtered[x,y] < 1){
        tanlogData_filtered[x,y] <- 1
      }
       else if (tanlogData_filtered[x,y] >= 1){
        tanlogData_filtered[x,y] <- matrix_position
       }
    }
}

  
  # This log-transforms every value in our data frame
  tanlogData_filtered <- log(tanlogData_filtered)
  # This converts our wavelength data back to standard values
  # (300-700 nm)
  tanlogData_filtered$wl <- exp(tanlogData_filtered$wl)

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })

# Applies our spline fitting function to our log-transformed reflectance data for
# each species
  spline_results_log <- lapply(tanlogData_filtered[-1], function(reflectance) {
    fit_splines_log(tanlogData_filtered$wl, reflectance)
  })
  
```




# Step 5: Species plots of splines on refl. and log refl. data

```{r}

# Function that plots the splines from each dataset for all species
plot_splines_with_metrics <- function(species_name, wl, reflectance, log_reflectance, spline_results, spline_results_log, rgb_colors) {
  
  # Extracts a single species spline results from each dataset list
  result <- spline_results[[species_name]]
  log_result <- spline_results_log[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Plots Cubic Splines for Reflectance Data with model scores
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Plots Cubic Splines for log Reflectance data with model scores
plot(wl, log_reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Spline (log Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "log Reflectance (%)")
lines(wl, predict(log_result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(log_result$log_reflectance_AIC, 3), "BIC:", round(log_result$log_reflectance_BIC, 2), "logLik:", round(log_result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
}

# Takes above function and uses a for loop to get every species' spline results plotted
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}

# Takes the above plots and puts them onto a pdf
pdf("cubic_splines_refl&logrefl_with_metrics.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}
dev.off()


```


## Step 6: Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}

# Create the spline summary table with coefficients, degree,
# knot placements, rgb values, and goodness-of-fit metrics.
# data frame just extracts data from the species list data from 
# each of the respective spline results
spline_table <- data.frame(
  
  Species = names(spline_results),

  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results_log, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results_log, function(x) round(x$log_reflectance_AIC, 2)),  

  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results_log, function(x) round(x$log_reflectance_BIC, 2)),

   Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results_log, function(x) round(x$log_reflectance_logLik, 2)),

  Degree_Reflectance = sapply(spline_results, function(x) c(x$degree)),
  Degree_Log_Reflectance = sapply(spline_results_log, function(x) c(x$degree)),
  
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


# Adding Internal Knots to the spline_table but I perform this outside of 
# the data frame function as there are some complications with inserting those
# values through the methodology we see below. This method, although an additional
# step, circumvents the necessity of adding each indiviual knot (for each species)
# as an individual column in the data frame

# Extracts the internal and boundary knot placements for each species 
# as a matrix for the splines using reflectance data
Internal_Knots = sapply(spline_results, function(x) round(c(x$internal_knots), 3))
Internal_Knots_log = sapply(spline_results_log, function(x) round(c(x$internal_knots), 3))

Boundary_Knots = sapply(spline_results, function(x) round(c(x$boundary_knots),3))
Boundary_Knots_log = sapply(spline_results_log, function(x) round(c(x$boundary_knots), 3))

# We must transpose the matrix to make the species names align along the rows
# to easily bind this matrix to the spline_table
Internal_Knots <- t(Internal_Knots)
Internal_Knots_log <- t(Internal_Knots_log)

Boundary_Knots <- t(Boundary_Knots)
Boundary_Knots_log <- t(Boundary_Knots_log)

# Attaching each matrix to each our spline_table
spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Internal_Knots_log)
spline_table <- cbind(spline_table, Boundary_Knots)
spline_table <- cbind(spline_table, Boundary_Knots_log)


# 4 for loops to add each set of knot data into a singular column
# in our spline_table data frame. Check knot vector min and max values
# to ensure your for loops do not take values from a different knot 
# dataset.

# Adds our new column
spline_table$Internal_Knots <- NA

# For loop to turn knots into a long character string
# and inputs it into our newly generated column for
# each species
for (i in 1:51){
  x <- c(spline_table[i,13:47])
  x <- as.numeric(x)
  spline_table[i,87] <- toString(x)
}


spline_table$Internal_Knots_log <- NA
for (i in 1:51){
  x <- c(spline_table[i,48:82])
  x <- as.numeric(x)
  spline_table[i,88] <- toString(x)
}

spline_table$Boundary_Knots <- NA
for (i in 1:51){
  x <- c(spline_table[i, 83:84])
  x <- as.numeric(x)
  spline_table[i,89] <- toString(x)
}

spline_table$Boundary_Knots_log <- NA
for (i in 1:51){
  x <- c(spline_table[i, 85:86])
  x <- as.numeric(x)
  spline_table[i,90] <- toString(x)
}

# Removes all extraneous knot columns
spline_table <- spline_table[,-c(13:86)]

# Verifying Knot Placements

# Only a single value should be printed if the internal knots are
# placed at the same points
unique(spline_table$Internal_Knots)
unique(spline_table$Internal_Knots_log)

# Making sure internal knot placements are identical between 
# reflectance and log reflectance data
unique(spline_table$Internal_Knots) == unique(spline_table$Internal_Knots_log)

# Only a single value should be printed if the boundary knots are
# placed at the same points
unique(spline_table$Boundary_Knots)
unique(spline_table$Boundary_Knots_log)

# Making sure boundary knot placements are identical between 
# reflectance and log reflectance data
unique(spline_table$Boundary_Knots) == unique(spline_table$Boundary_Knots_log)

# Verifying Degree of our Cubic Splines

# Only a single value should be printed if the is uniform
# This value should be 3, given we are using cubic splines
unique(spline_table$Degree_Reflectance)
unique(spline_table$Degree_Log_Reflectance)

# Making sure the degree of the splines are identical between 
# reflectance and log reflectance data
unique(spline_table$Degree_Reflectance) == unique(spline_table$Degree_Log_Reflectance)

# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

# Save the table as a CSV
write.csv(spline_table, "spline_summary_table.csv", row.names = FALSE)

# Fixing the PDF export by increasing the margins and adjusting the layout
pdf("spline_summary_table.pdf", width = 11, height = 8.5)
gridExtra::grid.table(spline_table, rows = NULL)
dev.off()

```


### Step 7: Model scores table for reflectance and log reflectance splines

Here, we want to create a separate data frame in order to easily compare the model scores for the spline fits to each set of data (reflectance versus log-transformed reflectance values). This data frame will contain the AIC, BIC, and logLik scores that we obtained from our gls function and then we identify which model has the "better" score, and therefore which dataset we should use for our parameter estimation and ancestral state reconstruction.

```{r}


# Creates a separate data frame only containing the species names and the model scores produced from our gls
spline_model_scores <- spline_table[,c(1,4:9)]

# Adds a column to the end of the data frame capturing the minimum AIC score between the two fits (lowest AIC score is the model you should select)
spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(AIC_Preferred_Model_Score = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

# Here we create a for loop system to identify and name which dataset used is preferred without having to manually check for each species.

# Placeholder vector to store which dataset is preferred to then be bound to the end of the model scoring data frame
preferred_model_name <- rep(NA, length(spline_model_scores$Species))

# for loop to determine which value (for each species) from our newly generated column matches to which dataset and store the output into the placeholder vector 
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,8] == spline_model_scores[i,2]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,8] == spline_model_scores[i,3]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,8] == spline_model_scores[i,2] & spline_model_scores[i,3] == spline_model_scores[i,8]){
    preferred_model_name[i] <- "Either"
  }
    }

# Attaches the placeholder vector to the model scores data frame
spline_model_scores <- cbind(spline_model_scores, preferred_model_name)

# Takes the column names of the data frame and stores them in a vector
column_names <- colnames(spline_model_scores)

# Adds a new value to name our newly attached column
column_names[9] <- "AIC_Preferred_Model_Name"

# Applies our column names vector as the names for our data frame
colnames(spline_model_scores) <- column_names



# We recreate an identical process for BIC scores

spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(BIC_Preferred_Model_Score = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(spline_model_scores$Species))
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,10] == spline_model_scores[i,4]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,10] == spline_model_scores[i,5]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,10] == spline_model_scores[i,4] & spline_model_scores[i,5] == spline_model_scores[i,10]){
    preferred_model_name[i] <- "Either"
  }
    }

spline_model_scores <- cbind(spline_model_scores, preferred_model_name)
column_names <- colnames(spline_model_scores)
column_names[11] <- "BIC_Preferred_Model_Name"
colnames(spline_model_scores) <- column_names



# We create an almost identical process for logLik scores. The only change is that instead of looking for the minimum logLik score, we are looking for the maximum logLik score.

spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(logLik_Preferred_Model_Score = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(spline_model_scores$Species))
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,12] == spline_model_scores[i,6]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,12] == spline_model_scores[i,7]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,12] == spline_model_scores[i,6] & spline_model_scores[i,7] == spline_model_scores[i,12]){
    preferred_model_name[i] <- "Either"
  }
    }

spline_model_scores <- cbind(spline_model_scores, preferred_model_name)
column_names <- colnames(spline_model_scores)
column_names[13] <- "logLik_Preferred_Model_Name"
colnames(spline_model_scores) <- column_names

spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 0] <- "Reflectance"
spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 1] <- "Log Reflectance"
spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 2] <- "Either"

# Reorders the data frame to put all of the model scores together
spline_model_scores <- spline_model_scores[,c(1,2,3,8,9,4,5,10,11,6,7,12,13)]

# Verifies if the data frame has been completed correctly
head(spline_model_scores)
```

# Step 8: Plotting model scores between datasets

Here, we want to plot the model scores from each of the datasets to each other. If our spline fits are identical, our model scores should fit along the line $y=x$. For an inconclusive determination, we would see an even split around the line if there is not a strong preference present. Otherwise, we should expect to a vast majority of data points lying on one side of the line over the other.

```{r}


# Create a vector of the color codes for each species to use in ggplot2 scatterplots
tanager_subset_colors <- c(spline_table[, "RGB_Color"])

# Puts the species name for each color as the names for the vector
names(tanager_subset_colors) <- spline_table$Species

# Character vector to be used as the title for our scatterplot legend (there could be other methods of doing this, but this was the one that I could figure out how to use with ggplot2)
title_for_legend <- "Species"


# AIC scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(intercept = 0, slope = 1)
+ xlab("Reflectance AIC Score")
+ ylab("Log Reflectance AIC Score")
+ ggtitle("AIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance AIC Score")
+ ylab("Log Reflectance AIC Score")
+ ggtitle("AIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)



# BIC scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC))
+ geom_point(aes(color = names(tanager_subset_colors))) 
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(intercept = 0, slope = 1)
+ xlab("Reflectance BIC Score")
+ ylab("Log Reflectance BIC Score")
+ ggtitle("BIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance BIC Score")
+ ylab("Log Reflectance BIC Score")
+ ggtitle("BIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)


# logLik scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance logLik Score") 
+ ylab("Log Reflectance logLik Score")
+ ggtitle("logLik Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(slope = 1, intercept = 0)
+ xlab("Reflectance logLik Score")
+ ylab("Log Reflectance logLik Score")
+ ggtitle("logLik Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
)



```


#Step 9: Summary statistics for 10nm wavelength bins from 300 to 700 nm

```{r, warning=FALSE}

# Creates a data frame without a column for the wavelengths
tanData_filtered_wowl <- data.frame(tanData_filtered[-1])
# Transpose the data frame to put the species names as the rows
tanData_filtered_wowl <- t(tanData_filtered_wowl)

# Create a counting vector for our for loop below
wl_bins <- seq(1, 400, 10)

# Creates a wavelength vector to match our counting vector to what our binned wavelengths would be
wavelengths <- 300:700

# 3 blank vectors to add summary statistics to. Each respectively will contain the mean, variance, and standard deviation for each 10nm wavelength bin
wl_mean <- rep(NA, 40)
wl_var <- rep(NA, 40)
wl_sd <- rep(NA, 40)

# One vector to store the raw data and a blank data frame to store all of the reflectance values for each wavelength bin
wl_data <- NULL
wl_dataframe <- NA

# for loop to extract the mean, var, and sd from each wavelength bin by using a sequence of columns and performing a summary function on that group of data. Each value is stored in its respective vector and the data is stored within our data frame. For the final bin of data, which has length 11 rather than 10, we do not attach it to our data frame, and leave it stored in our wl_data vector.
for (i in 1:40){
  # Creates our 10nm bins up until 690 nm
  sequence <- seq(wl_bins[i],(wl_bins[i])+9, 1)
  
  # Verifies that our vector is working and can match it to our wavelength bins for future clarification
  print(sequence)
  print(wavelengths[sequence])

  # Summary stats are stored in their respective locations
  wl_mean[i] <- mean(tanData_filtered_wowl[,sequence])
  wl_var[i] <- var(tanData_filtered_wowl[,sequence])
  wl_sd[i] <- sd(tanData_filtered_wowl[,sequence])
  
  # Takes the reflectance values from our data frame and stores them in a vector
  wl_data <- c(tanData_filtered_wowl[,sequence])

  # Takes our vector and stores them within a data frame for future use
  wl_dataframe <- rbind(wl_dataframe, wl_data)
  
  # Need to add this condition due to unequal wavelength bin sizes
  if (i == 40){
    sequence <- 390:400
    print(sequence)
  
    wl_mean[i] <- mean(tanData_filtered_wowl[,sequence])
    wl_var[i] <- var(tanData_filtered_wowl[,sequence])
    wl_sd[i] <- sd(tanData_filtered_wowl[,sequence])
    
    wl_data <- c(tanData_filtered_wowl[,sequence])
  }
  
  # Verifies that the length of each bin is 10 nm intervals except for our final interval, which should be 11 nm
  print(length(wl_data))
  
  # Verifying that for loop worked by comparing the values of our summary stats from our extractions match to the initial dataset. If so, all values should return TRUE.
  test_mean <- (c(tanData_filtered_wowl[,sequence]))
  print(mean(test_mean) == wl_mean[i])
}

# Combines all of our summary stat vectors into a matrix
wl_summary_stats <- cbind(wl_mean, wl_var)
wl_summary_stats <- cbind(wl_summary_stats, wl_sd)

# Wavelength bin vector
binned_wl <- c("300-309","310-319","320-329","330-339","340-349","350-359", "360-369","370-379","380-389","390-399","400-409","410-419","420-429","430-439","440-449","450-459","460-469","470-479","480-489","490-499","500-509","510-519","520-529","530-539", "540-549","550-559","560-569","570-579","580-589","590-599","600-609","610-619","620-629","630-639","640-649","650-659","660-669","670-679","680-689","690-700")

# Applies our wavelength bins as names for our summary stat matrix
rownames(wl_summary_stats) <- binned_wl

# Turns our summary stat matrix into a data frame
wl_summary_stats <- data.frame(wl_summary_stats)

# Verifying that our data frame looks as it should
head(wl_summary_stats)


# Transposes matrix to place wavelength bins as columns
wl_dataframe <- t(wl_dataframe)

# Removes both the NA column and the last column (690-700 nm) as this column has omitted data due to column length coercion (561 data points -> reduced to 510 data points)
wl_dataframe <- wl_dataframe[,2:40]

# Takes our dataframe and turns it into a singular vector, and adds our data points from 690-700 nm. We do this to use the boxplot function seamlessly.
wl_dataframe <- c(wl_dataframe, wl_data)


# Blank vector to store our wavelength bins to identify which values in wl_dataframe come from which wavelength bin
wl_ranges <- NULL

# for loop to create a long character vector listing each wavelength bin equal to number of data points from each wavelength bin
for (i in 1:40){
  if (i <= 39){
  
  x <- rep(binned_wl[i], 510)
  
  wl_ranges <- cbind(wl_ranges, x)
  
  }
  
    if (i == 40){
    
    x <- rep(binned_wl[i], 561)
    wl_ranges <- c(wl_ranges, x)
      
    }
}

# Binds our reflectance data to each wavelength bin into a matrix
wl_dataframe <- cbind(wl_dataframe, wl_ranges)

# Verifies matrix was formed correctly
head(wl_dataframe)

# Adds names to our matrix
colnames(wl_dataframe) <- c("Reflectance_Values", "Wavelength_Bins")

# Converts our matrix into a data frame
wl_dataframe <- data.frame(wl_dataframe)

# Checks that our reflectance values are numerical values and that our wavelength bins are character values
str(wl_dataframe)

# Converts our Reflectance_Values column into numerical values to use for our boxplot
wl_dataframe$Reflectance_Values <- as.numeric(wl_dataframe$Reflectance_Values)

# Verifies if our Reflectance_Values column is now numerical values
str(wl_dataframe)

# Sequence vector with the midpoints of our wavelength bins
sequence <- seq(305, 695, 10)

# Blank vectors to store RGB codes into
color_for_plots_V1 <- NULL
color_for_plots_V2 <- NULL
color_for_plots_V3 <- NULL
color_for_plots_V4 <- NULL

# for loop to generate different color options for the boxplots. Here we parameterize different Gaussian curves of spectra at the midpoint of each wavelength interval with varying widths and heights of our curves.
for (i in 1:length(sequence)){
  
  color_for_plots_V1[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i]))
  
  color_for_plots_V2[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], width_gauss = 10))
  
  color_for_plots_V3[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], width_gauss = 10, ylim = c(0, wl_summary_stats[i,1])))
  
  color_for_plots_V4[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], ylim = c(0, wl_summary_stats[i,1])))
}


# Boxplots of the reflectance data for each wavelength bin with different color options

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V1, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V2, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V3, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V4, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

```


### Step 10: Spline Coefficient Extraction for BEAST

```{r}


# Empty matrix for the spline coefficients
spline_coef_data <- NA

# for loop to extract spline coefficients for each species from our spline_results (list)
for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  spline_coefficients <- spline_results[[name_vector]]
  
  spline_coefficients <- spline_coefficients$reflectance_coef
  
  spline_coef_data <- rbind(spline_coef_data, spline_coefficients)
  
  
}

# Removes NA row
spline_coef_data <- spline_coef_data[-1,]

# Turns our matrix into a data frame
spline_coef_data <- data.frame(spline_coef_data)

# Adds species labels to each row of spline coefficients
rownames(spline_coef_data) <- names(spline_results)

# Explicit species name vector to add to our data frame
species <- as.character(names(spline_results))

# Adds a species name vector to our data frame. This is needed for BEAST to know what spline coefficients are for each species
spline_coef_data <- cbind(species, spline_coef_data)

# Vector containing the names of the species column and each spline coefficient extracted
coefficient_names <- c("Species", "Intercept", "Coefficient.1","Coefficient.2","Coefficient.3","Coefficient.4","Coefficient.5","Coefficient.6","Coefficient.7","Coefficient.8","Coefficient.9","Coefficient.10","Coefficient.11","Coefficient.12","Coefficient.13","Coefficient.14","Coefficient.15","Coefficient.16","Coefficient.17","Coefficient.18","Coefficient.19","Coefficient.20","Coefficient.21","Coefficient.22","Coefficient.23","Coefficient.24","Coefficient.25","Coefficient.26","Coefficient.27","Coefficient.28","Coefficient.29","Coefficient.30","Coefficient.31","Coefficient.32","Coefficient.33","Coefficient.34","Coefficient.35","Coefficient.36","Coefficient.37","Coefficient.38")

# Applies our coefficient name vector to our data frame
colnames(spline_coef_data) <- coefficient_names

# Verifies our data is in a data frame
str(spline_coef_data)

# Writes a text file of our data frame to use for BEAST
write_tsv(spline_coef_data, file = "spline_coefficients_BEAST.txt")
write.delim(spline_coef_data, file = "spline_coefficients_BEAST.txt")



```

### Step 11: Summary Statistics for the Spline Coefficients

In this chunk, we want to see whether the spline coefficients show similar levels of variation to the wavelength bins from Step 9. Although spline coefficients are not exclusive representations of a singular 10 nm wavelength bin, but each spline coefficient has more weight on a particular bin over the other bins that the coefficient locally supports.

```{r}

spline_coefficients <- NULL

spline_coefficient_names <- NULL

for (i in 2:40){
  
  x <- i
  
  coefficients <- c(spline_coef_data[,x])
  
  spline_coefficients <- c(spline_coefficients, coefficients)
  
  names <- rep((0:38)[i-1], 51)
  
  spline_coefficient_names <- c(spline_coefficient_names, names)
  
}

spline_coefficients <- cbind(spline_coefficients, spline_coefficient_names)

spline_coefficients <- data.frame(spline_coefficients)

spline_coefficients$spline_coefficients <- as.numeric(spline_coefficients$spline_coefficients)

colnames(spline_coefficients) <- c("coefficients","coefficient_names")

boxplot(spline_coefficients$coefficients ~ spline_coefficients$coefficient_names, col = color_for_plots_V1, label = c(rep(as.character(98), 39)), main = "Summary Statistics for Thraupidae Spline Coefficients (51 Species)", xlab = "Spline Coefficients", ylab = "Value")

```


# Step 12: OUTLINING BEAST AND TRACER PROCESS

# Step 13: Analyzing diffusion rates of spline coefficients

```{r}

# Loads in the .txt file containing our diffusion rate data for our spline coefficients
coefficient_diffusion_rates <- read.delim("diffusion_rate_data.txt")

# Manually written vector to contain an ordered list of the spline coefficients
coefficient_diffusion_rates_names <- c("Intercept.diffusionRate", "Coefficient.1.diffusionRate","Coefficient.2.diffusionRate","Coefficient.3.diffusionRate","Coefficient.4.diffusionRate","Coefficient.5.diffusionRate","Coefficient.6.diffusionRate","Coefficient.7.diffusionRate","Coefficient.8.diffusionRate","Coefficient.9.diffusionRate","Coefficient.10.diffusionRate","Coefficient.11.diffusionRate","Coefficient.12.diffusionRate","Coefficient.13.diffusionRate","Coefficient.14.diffusionRate","Coefficient.15.diffusionRate","Coefficient.16.diffusionRate","Coefficient.17.diffusionRate","Coefficient.18.diffusionRate","Coefficient.19.diffusionRate","Coefficient.20.diffusionRate","Coefficient.21.diffusionRate","Coefficient.22.diffusionRate","Coefficient.23.diffusionRate","Coefficient.24.diffusionRate","Coefficient.25.diffusionRate","Coefficient.26.diffusionRate","Coefficient.27.diffusionRate","Coefficient.28.diffusionRate","Coefficient.29.diffusionRate","Coefficient.30.diffusionRate","Coefficient.31.diffusionRate","Coefficient.32.diffusionRate","Coefficient.33.diffusionRate","Coefficient.34.diffusionRate","Coefficient.35.diffusionRate","Coefficient.36.diffusionRate","Coefficient.37.diffusionRate","Coefficient.38.diffusionRate")

# Blank vector to store the order of the columns in relation to the order of our spline coefficient names vector
diffusion_rate_column_order <- NULL

# for loop to figure out the location of each column to to put it in sequential order (Intercept, 1, 2, ..., 38). This step is necessary as the columns are not in this sequential order when extracted from BEAST.
for (i in 1:length(coefficient_diffusion_rates_names)){
  diffusion_rate_column_order[i] <- which(coefficient_diffusion_rates_names[i] == colnames(coefficient_diffusion_rates))
    print(which(coefficient_diffusion_rates_names[i] == colnames(coefficient_diffusion_rates)))
}

# Reorders the columns of our data frame to match the sequential order that we would like
coefficient_diffusion_rates <- coefficient_diffusion_rates[,c(1,diffusion_rate_column_order)]

# Verifies that we have the correct order that we are looking for
head(coefficient_diffusion_rates)

# Transposes the data frame to make the coefficients the rows
coefficient_diffusion_rates <- t(coefficient_diffusion_rates)

# When transposing the data frame, our data frame became a matrix, and here we convert it back into a data frame
coefficient_diffusion_rates <- data.frame(coefficient_diffusion_rates)

# Turns the column names with the values in the first row
colnames(coefficient_diffusion_rates) <- coefficient_diffusion_rates[1,]

# We remove the first row as they are now the column names for our data frame
coefficient_diffusion_rates <- coefficient_diffusion_rates[-1,]

# Verifies the structure of our object. We can see that all numerical values had been coerced into character vectors
str(coefficient_diffusion_rates)

# for loop to convert all columns into numerical values rather than character values (with the exception of the 95% HPD interval and value range columns as there are not singular values and do not work the as.numeric function)
for (i in c(1:5,7,9:11)){
coefficient_diffusion_rates[,i] <- as.numeric(coefficient_diffusion_rates[,i])
}

# Verifies that the columns that we converted are now numeric in nature
str(coefficient_diffusion_rates)

# Scatterplot showing the mean diffusion rate values for our spline coefficients, showing error bars equivalent to +/- 1 standard deviation
(ggplot(coefficient_diffusion_rates, aes(x = 0:38, y = mean))
+ geom_errorbar(aes(ymax = mean+stdev, ymin = mean-stdev), color = "orangered")
+ geom_point(color = "royalblue")
+ ggtitle("Diffusion Rates for Spline Coefficients", subtitle = "0 = Intercept Coefficient")
+ xlab("Spline Coefficients")
+ ylab("Diffusion Rate")
)


```

# Step 14: Reconstucting splines (methods)

One of the main points of reconstructing splines is that we need to do it without the predictive power of a generalized least squares model, which is how we did it in Step 5. This is due to the fact that when we allow our coefficients to diffuse in BEAST for an ancestral state reconstruction (ASR), the only things that we have to reconstruct our diffused splines will just be diffused coefficients and the basis that we are working with (300-700 nm). Below, I will use a case study, using TanCyo (Tangara cyanotis) to show how we can construct splines for a species without the need for a least squares model.



#### Spline Reconstruction from gls function
```{r}

# Extracting all of the data from our fit_splines function into a new object (named after our focal species)
TanCyo <- spline_results[["TanCyo"]]

# Here we plot a scatterplot using the predicted points from our gls model for this species
plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "TanCyo gls Spline Reconstruction")



# Side-by-side plot comparison of our gls reconstructed plot and the plot from Step 5 (using the actual reflectance data)

par(mfrow=c(1,2), mar = c(5.1,4.1,4.1,1.1))

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 0.6)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

plot(tanData_filtered$wl, tanData_filtered$TanCyo, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", "TanCyo"),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(tanData_filtered$wl, predict(spline_results[["TanCyo"]]$reflectance_spline_fit), col = rgb_colors[["TanCyo"]], lwd = 2)
mtext(paste("AIC:", round(spline_results[["TanCyo"]]$reflectance_AIC, 3), "BIC:", round(spline_results[["TanCyo"]]$reflectance_BIC, 2), "logLik:", round(spline_results[["TanCyo"]]$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))



```

#### Spline Reconstruction with only spline coefficients and a basis

I could not find an intuitive way to do this through just base R, but by using the package splines2, I am able to reconstruct the splines with just this information available.

```{r}

# Creating a basis matrix using the function bSpline from the splines2 package. We use the same wavelength range and maintain the same degrees of freedom (35 knots)
bspline_matrix_bSpline <- bSpline(tanData_filtered$wl, df = 38)

# Verifying that the bSpline and bs functions produce identical basis matrices (output should be TRUE)
identical(data.frame(bs(tanData_filtered$wl, df = 38)), data.frame(bSpline(tanData_filtered$wl, df = 38)))

# Extract the coefficients available to us from our gls model fit into its own vector
TanCyo_spline_coefficients <- TanCyo$reflectance_coef

# Must make coefficients from 2:39 as bSpline function does not create an intercept coefficient in its output, and therefore cannot use it in reconstructions
coef_spline_reconstruction <- cbind(300:700, predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Adds names to the columns of the matrix
colnames(coef_spline_reconstruction) <- c("wl", "reflectance")

# Turns the matrix into a data frame
coef_spline_reconstruction <- data.frame(coef_spline_reconstruction)

# Code to show why we need to use the splines2 package
# Basis matrix produced by the function bs
bspline_matrix_bs <- bs(tanData_filtered$wl, df = 38)

# Object that would be created using the bs produced matrix. The output is another matrix
str(predict(bspline_matrix_bs, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Object that would be created using the bSpline produced matrix. The output is a one column matrix (or a vector)
str(predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Plotting the spline reconstruction using our matrix/coef method
plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "TanCyo Coefficient Spline Reconstruction", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))


# Side-by-side plots of the gls reconstruction and matrix/coef reconstruction
par(mfrow=c(1,2), mar = c(5.1,4.1,4.1,1.1))

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 1)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)


plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))
```

From the plots above, we can see two key differences from our initial plot. The first is that the color between the plots. The gls plot has an RGB color of `r TanCyo$reflectance_rgb`, while the coefficient method has a color of `r spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero"))`. The next major difference (and directly impacts why there is a color change), is that the reflectance scales are completely different from another, with all values on the left plot being greater than 0, while the data points on the right plot do not follow that trend. So if using a basis and spline coefficients to rebuild a curve, will we lose all of the biological information, where we only retain the shape of the curve? No. Earlier in our reconstruction, we mentioned that we had to omit the intercept coefficient due to `predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39])))` not being able to use it. But the intercept coefficient is important in dictating where to place the spline along the y-axis, thus all we have to do to our data is to add the spline coefficient value to all of our data points.

```{r message = FALSE}

# Prints TanCyo intercept coefficient
TanCyo$reflectance_coef[1]

# Plots the reconstructed splines from the matrix/coef method but adds the intercept values to the reconstructed reflectance values
plot(x = 300:700, y = coef_spline_reconstruction$reflectance + TanCyo$reflectance_coef[1], pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

# Copies our coef_spline_reconstruction data frame
coef_spline_reconstruction_plusintercept <- coef_spline_reconstruction

# Adds the intercept coefficient value to all of the reflectance values
coef_spline_reconstruction_plusintercept$reflectance <- coef_spline_reconstruction_plusintercept$reflectance + TanCyo$reflectance_coef[1]

# Side-by-side plots of the initial data, gls reconstruction, matrix/coef reconstruction, modified matrix/coef reconstruction
par(mfrow=c(2,2), mar = c(5.1,4.1,4.1,1.1))

plot(tanData_filtered$wl, tanData_filtered$TanCyo, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", "TanCyo"),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(tanData_filtered$wl, predict(spline_results[["TanCyo"]]$reflectance_spline_fit), col = rgb_colors[["TanCyo"]], lwd = 2)
mtext(paste("AIC:", round(spline_results[["TanCyo"]]$reflectance_AIC, 3), "BIC:", round(spline_results[["TanCyo"]]$reflectance_BIC, 2), "logLik:", round(spline_results[["TanCyo"]]$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 0.6)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)


plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", cex = 0.6, col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

plot(x = 300:700, y = coef_spline_reconstruction_plusintercept$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", cex = 0.6, col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction_plusintercept), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))


# Verification that our final spline reconstruction produces an identical color to the initial reflectance data and the gls reconstruction method

# Plot 1
rgb_colors[["TanCyo"]]
# Plot 2
TanCyo$reflectance_rgb
# Plot 3
spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero"))
# Plot 4
spec2rgb(procspec(as.rspec(coef_spline_reconstruction_plusintercept), fixneg = "zero"))

```
Thus, we have shown we have accurately recreated the spline from our gls model and can produce identical colors to that of the original data just from the spline coefficients for a species and by using a basis for the trait data.


### Step 15: What do the coefficients mean?

In the last step, we were able to reconstruct what the splines were through the use of a basis (wavelengths from 300-700 nm) and spline coefficients. We were able to deduce that the intercept was the key component to maintaining the biological meaning to our splines if ran through BEAST. Here we attempt to identify the function of the different spline coefficients through the case study of TanCyo. 

```{r}

# Taking our matrix created from bSpline and turning it into a matrix object
basis_spline_matrix <- matrix(bspline_matrix_bSpline, nrow = 401, ncol = 38)

# Turning our TanCyo reflectance coefficients into a 38x1 matrix
spline_coefficient_matrix <- matrix(TanCyo$reflectance_coef[2:39])

# Multiplying the matrices using the matrix multiplication operator (%*%)
spline_reconstruction <- basis_spline_matrix %*% spline_coefficient_matrix

# Verification that this matrix multiplication is how we are getting our curves through the spline functions (does not include the addition of the intercept coefficient here although if the answer is TRUE, adding the intercept to both objects will still produce a TRUE output)
identical(c(spline_reconstruction), coef_spline_reconstruction$reflectance)



```
IT'S JUST MATRIX MULTIPLICATION, I HAVE NO IDEA WHAT THE BIOLOGICAL INTERPRETATION OF THE COEFFICIENTS ARE BUT I DOUBT IT IS USEFUL TO TRY AND UNDERSTAND THEM OR TAKE MEANS OF THEM ETC. 
The real question at this stage is to identify what the basis matrix represents for our system, as it is not clear as to what it could represent. Are the spline coefficients just a scalar to shape the curve?




### Step 16: What do spline coefficients do? What does the basis matrix mean?
```{r}




TanCyo_spline_reconstruction <- cbind(300:700,predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))


plot(300:700, TanCyo_spline_reconstruction[,2])

TanCyo_adjusted_coefficients <- TanCyo_spline_coefficients[2:39]
print(TanCyo_spline_coefficients[21])
TanCyo_adjusted_coefficients[20] <- TanCyo_adjusted_coefficients[20]+1

TanCyo_adjusted_coefficients <- cbind(300:700, predict(bspline_matrix_bSpline, coef = TanCyo_adjusted_coefficients))
plot(300:700, TanCyo_adjusted_coefficients[,2])


par(mfrow=c(1,2))
plot(300:700, TanCyo_spline_reconstruction[,2], pch = 19, main = "TanCyo Base Coef.")
plot(300:700, TanCyo_adjusted_coefficients[,2], pch = 19, main = "TanCyo Adjusted Coef.")
par(mfrow=c(1,1))

spline_coef_comparison <- cbind(predict(bspline_matrix_bSpline, coef = (c(TanCyo_spline_coefficients[2:39]))), c(TanCyo_adjusted_coefficients[,2]))
spline_coef_comparison <- cbind(300:700, spline_coef_comparison)

```
I do not think the basis matrix or the spline coefficients have any inherit biological information.

### Step 17: Comparing our splines for mean reflectance data and mean spline coefficients

```{r}

mean_reflectance_values <- NULL
for (i in 1:401){

  x <- i
  mean_reflectance_values[i] <- mean(tanData_filtered_wowl[,x])

}

random_number <- round(runif(1, min = 1, max = 401), 0)
mean_reflectance_values[random_number] == mean(tanData_filtered_wowl[,random_number])

mean_reflectance_values <- cbind(300:700, mean_reflectance_values)

spline_fit_mean_reflectance <- gls(mean_reflectance_values[,2] ~ bs(mean_reflectance_values[,1], df = 38), correlation = corAR1(form = ~1))

mean_reflectance_values <- cbind(mean_reflectance_values, predict(spline_fit_mean_reflectance)) 

colnames(mean_reflectance_values) <- c("wl", "reflectance", "spline_fit")

plot(x = 300:700, y = mean_reflectance_values[,"reflectance"], xlab = "Wavelength (nm)", ylab = "Reflectance (%)", main = "Mean Reflectance Values", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_reflectance_values[,"spline_fit"], col = spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero")), lwd = 3)

mean_spline_coefficients <- NULL
for (i in 1:39){
  
  x <- i+1
  
  mean_spline_coefficients[i] <- mean(spline_coef_data[,x])
  
}

random_number <- round(runif(1, min = 1, max = 39), 0)
mean_spline_coefficients[random_number] == mean(spline_coef_data[,random_number+1])

mean_spline_coefficients_output <- cbind(300:700, predict(bspline_matrix_bSpline, coef = mean_spline_coefficients[2:39]))

colnames(mean_spline_coefficients_output) <- c("wl", "reflectance")

mean_spline_coefficients_output[,2] <- mean_spline_coefficients_output[,2] + mean_spline_coefficients[1]

plot(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], main = "Mean Spline Coefficients", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], col = spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero")), lwd = 3)

spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero"))
spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero"))

par(mfrow=c(1,2))

plot(x = 300:700, y = mean_reflectance_values[,"reflectance"], xlab = "Wavelength (nm)", ylab = "Reflectance (%)", main = "Mean Reflectance Values", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_reflectance_values[,"spline_fit"], col = spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero")), lwd = 3)

plot(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], main = "Mean Spline Coefficients", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], col = spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero")), lwd = 3)

par(mfrow=c(1,1))

```



### Step 18: Plotting basis functions

What do the basis functions mean? Do they have the same wavelength width? How do they relate to the basis matrix? How are they represented?

Reference: https://math.stackexchange.com/questions/699113/what-is-the-relationship-between-cubic-b-splines-and-cubic-splines

#### Plotting the basis functions
```{r}

basis_functions <- matrix(bspline_matrix_bSpline, nrow = 401, ncol = 38)


plot(x = 300:700, y = basis_functions[,1], ylim = c(0,1), pch = 19, col = "white")
for (i in 1:38){
  x <- i
  lines(x = 300:700, y = basis_functions[,x], lwd = 3, col = i)
}

```


Why are the basis functions not equivalent in size, and why does the last basis function look completely different from the other basis functions?


```{r}

basis_function_width <- NULL

for (i in 1:38){
  
  x <- i
  
  basis_function <- c(bspline_matrix_bSpline[,x])
  
  basis_function[basis_function == 0] <- NA
  
  print(length(na.omit(basis_function)))
  
  basis_function_width[i] <- length(na.omit(basis_function))

}


plot(x = 1:38, y = basis_function_width, main = "Basis Function Widths", col = "red", pch = 19, ylab = "Wavelength Width (nm)", xlab = "Basis Function")



z <- bSpline(300:700, df = 38, degree = 0)
wavelength <- NULL
basis_function_value <- NULL
for (i in 1:38){
  
  x <- i
  
  basis_function <- c(z[,x])
  
  basis_function <- cbind(300:700, basis_function)
  
  basis_function[basis_function == 0] <- NA
  
  print(length(na.omit(basis_function)))
  
  basis_function <- (na.omit(basis_function))
  
  wavelength <- c(wavelength, basis_function[,1])
  
  basis_function_value <- c(basis_function_value, basis_function[,2])
  
}

plot(z)
```
Why there are no values from 300:311 is still unknown. Plausible answer is that the basis functions start at the first internal knot and not the first boundary knot.

Reference: Yadav et al. 2020 ("A Review on XIGA method for computational fracture mechanics applications")

```{r}
y <- cbind(wavelength, basis_function_value)

y[y == 0] <- NA

y <- na.omit(y)

y


for (i in 1:401){
  
  x <- i
  
  bspline_matrix_bSpline[x,]
  
}


```



#### How do the basis functions change depending on the spline coefficients?

```{r}

scalar_values <- c(-0.01, 0, 0.01, 0.1, 1, 2)

length(scalar_values)

for (i in 1:length(scalar_values)){
  
  x <- matrix(rep(scalar_values[i], 38), nrow = 38, ncol = 1)
  
  warped_basis_functions <- c(basis_functions %*% x)
  
  print(warped_basis_functions)
  
  plot(x = 300:700, warped_basis_functions, main = paste("Spline Coefficients = ", scalar_values[i], sep = ''))
  
}

for (i in 1:401){
  x <- i
  print(sum(basis_functions[x,]))
  
}

```
Each row (13+) has a sum of 1. Why do the previous rows not sum to 1, especially when there appears to be symmetry within the basis functions? Why do the columns sum to 1?

Spline coefficients act as scalar values to warp the magnitude of each point on the basis function.



### Step 19: Showing how the spline coefficients and basis matrix works

```{r}


TanCya <- spline_results[["TanCya"]]

TanCya_spline_coef <- TanCya$reflectance_coef

for (i in 2:39){
  
  x <- i
  
  sequence <- 2:i
  
  y <- i-1
  
  spline_coef_subset <- matrix(TanCya_spline_coef[sequence])
  
  basis_matrix_subset <- matrix(bspline_matrix_bSpline[,(1:y)], nrow = 401, ncol = y)
  
  spline_recon_subset <- basis_matrix_subset %*% spline_coef_subset
  
  plot(x = 300:700, y = spline_recon_subset + TanCya_spline_coef[1], ylim = c(0, 75), pch = 19, col = TanCya$reflectance_rgb, main = paste("Spline Coefficient =<", i-1), ylab = "Reflectance (%)", xlab = "Wavelength (nm)")
  
}


```


### Step 20: Fitting cubic functions to spline data

This chunk of code is to confirm how the splines work. Current idea of how the math works. For some domain x (wavelength: 300:700), we create a series of $k$ basis functions ($F_k(x)$) that can be transformed by spline coefficients ($c_k$). Thus, each point (x) can be defined as follows: $N(x) = \sum_{n=1}^k c_k*F_k(x)$. The output of the basis function transformation will create a piecewise polynomial of cubic functions.

Here, we are going to test/show that this is the case using the TanCyo data.

```{r}

# We extract out the data used in the first knot (approximately 11 nm)
basis_function_spline1 <- matrix(c(bspline_matrix_bSpline[1:12,]), nrow = 12, ncol = 38)

# We extract our spline coefficients from TanCyo (ignoring the intercept coefficient)
TanCyo_spline_coefficients <- matrix(TanCyo$reflectance_coef[2:39], ncol = 1)

# We multiply our matrices to get our predicted values
TanCyo_spline1 <- basis_function_spline1 %*% TanCyo_spline_coefficients

# We add our intercept coefficient to our predicted values
TanCyo_spline1 <- TanCyo_spline1 + TanCyo$reflectance_coef[1]

# Plotting to verify code ran correctly
plot(x = 300:311, y = c(TanCyo_spline1), main = "TanCyo Spline 1", pch = 19, col = TanCyo$reflectance_rgb, xlab = "Wavelength (nm)", ylab = "Reflectance (%)")

# Wavelength subset
wavelength_subset1 <- 300:311

# Fitting a cubic function to our predicted values
lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))

# Plotting
plot(x = 300:311, y = c(TanCyo_spline1), main = "TanCyo Spline 1", pch = 19, col = TanCyo$reflectance_rgb, xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(x = 300:311, y = predict(lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))), col = "yellow")

# Repeat the process with the second spline for TanCyo

basis_function_spline2 <- matrix(c(bspline_matrix_bSpline[13:23,]), nrow = 11, ncol = 38)
TanCyo_spline2 <- basis_function_spline2 %*% TanCyo_spline_coefficients
TanCyo_spline2 <- TanCyo_spline2 + TanCyo$reflectance_coef[1]
wavelength_subset2 <- 312:322
lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3))
plot(x = 312:322, y = c(TanCyo_spline2), main = "TanCyo Spline 2", pch = 19, col = TanCyo$reflectance_rgb, xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(x = 312:322, y = predict(lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3))), col = "yellow")


# Combined plot

plot(300:322, y = c(c(TanCyo_spline1), c(TanCyo_spline2)), main = "TanCyo Splines 1 & 2", col = TanCyo$reflectance_rgb, xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(x = 300:322, y = c(predict(lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))), predict(lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3)))), col = "yellow")
lines(x = 300:311, y = predict(lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))), col = "red")
lines(x = 312:322, y = predict(lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3))), col = "blue")
abline(v = as.numeric(TanCyo$internal_knots[1]), col = "yellowgreen", lty = 2)


# Plotting side-by-side with actual TanCyo data

par(mfrow=c(1,2))

plot(300:322, y = c(c(TanCyo_spline1), c(TanCyo_spline2)), main = "TanCyo Splines 1 & 2", col = TanCyo$reflectance_rgb, xlab = "Wavelength (nm)", ylab = "Reflectance (%)", pch = 19)
lines(x = 300:322, y = c(predict(lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))), predict(lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3)))), col = "yellow")
lines(x = 300:311, y = predict(lm(c(TanCyo_spline1) ~ wavelength_subset1 + I(wavelength_subset1^2) + I(wavelength_subset1^3))), col = "red")
lines(x = 312:322, y = predict(lm(c(TanCyo_spline2) ~ wavelength_subset2 + I(wavelength_subset2^2) + I(wavelength_subset2^3))), col = "blue")
abline(v = as.numeric(TanCyo$internal_knots[1]), col = "yellowgreen", lty = 2)

plot(x = 300:322, y = predict(TanCyo$reflectance_spline_fit)[1:23], col = TanCyo$reflectance_rgb, pch = 19, main = "TanCyo Data")
abline(v = as.numeric(TanCyo$internal_knots[1]), col = "yellowgreen", lty = 2)

par(mfrow=c(1,1))

```

Here we add a for loop to do this for all cubic polynomials fit to our data

```


x <- 300:700
y1 = z$coefficients[4]*(x^3) + z$coefficients[3]*(x^2) + z$coefficients[2]*(x) + z$coefficients[1]

plot(x = 300:700, y = y1)










```


### Step 21: General plots for presentations

#### Colorful tanager plots

```{r}

internal_knots <- TanCyo$internal_knots

plot(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyc))), lwd = 5, col = as.character(spec2rgb(procspec(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyc))), fixneg = "zero"))), main = expression(italic("Tangara cyanocephala")))

plot(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyv))), lwd = 5, col = as.character(spec2rgb(procspec(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyv))), fixneg = "zero"))), main = expression(italic("Tangara cyanoventris")))


plot(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyc))), lwd = 5, col = as.character(spec2rgb(procspec(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyv))), fixneg = "zero"))))
for (i in 1:length(internal_knots)){
  
  abline(v = internal_knots[i], col = "orange")
  
}

internal_knots[12:16]

internal_knots <- TanCyo$internal_knots

TanCyc_subset <- tanData_filtered[133:180, c("wl", "TanCyc")]

as.character(spec2rgb(procspec(as.rspec(data.frame(cbind(tanData_filtered$wl, tanData_filtered$TanCyc))), fixneg = "zero")))

plot(x = min(TanCyc_subset$wl):max(TanCyc_subset$wl), y = TanCyc_subset$TanCyc, col = "white", ylab = "Reflectance (%)", xlab = "Wavelength (nm)", main = expression(italic("Tangara cyanocephala")))
lines(x = min(TanCyc_subset$wl):max(TanCyc_subset$wl), y = TanCyc_subset$TanCyc, col = "#4585AAFF", lwd = 5)



plot(x = min(TanCyc_subset$wl):max(TanCyc_subset$wl), y = TanCyc_subset$TanCyc, col = "white", ylab = "Reflectance (%)", xlab = "Wavelength (nm)", main = expression(italic("Tangara cyanocephala")))
lines(x = min(TanCyc_subset$wl):max(TanCyc_subset$wl), y = TanCyc_subset$TanCyc, col = "#4585AAFF", lwd = 5)
for (i in 1:length(internal_knots)){
  
  abline(v = internal_knots[i], col = "orange")
  
}

```



#### Knot placements

```{r}

internal_knots <- TanCyo$internal_knots

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = "white", main = "TanCyo Crown Reflectance", xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
for (i in 1:length(internal_knots)){
  
  abline(v = internal_knots[i], col = "lightgreen")
  
}

```
#### Knot placements with data


```{r}


plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = as.character(TanCyo$reflectance_rgb), main = "TanCyo Crown Reflectance", xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
for (i in 1:length(internal_knots)){
  
  abline(v = internal_knots[i], col = "lightgreen")
  
}




```



#### Loop to gather cubic polynomial coefficients for the plot

```

basis_matrix_with_wl <- cbind(tanData_filtered$wl, bspline_matrix_bSpline)

# need to isolate what rows are within each knot wl bin
# need to find which spline coefficients are applicable to each basis function
## 

basis_matrix_with_wl <- data.frame(basis_matrix_with_wl)

if (i == 1) {
for (i in 1:length(internal_knots)){

sequence <- 300:internal_knots[i]

print(tail(sequence))
}
else {
#x <- basis_matrix_with_wl %>% filter(V1 == sequence)
}
}


```


#### Basic non-empirical example


```{r}

# Data and basis matrix objects
data <- c(2,1,1,2,3,3,2,1,1,2,5,5,6,5,5,6,8,5,6,7,7,6,6,5,5,8,8,9,8,8,7)
b.matrix <- bSpline(10:40, df = 6)

# Plotting data
plot(x = 10:40, y = data, ylab = "", xlab = "", pch = 19)

# GLS model of our splines & data
gls.model <- gls(data ~ bs(10:40, df = 6), correlation = corAR1(form = ~1))

# Plotting data with spline line
plot.new()
plot(x = 10:40, y = data, ylab = "", xlab = "", pch = 19)
lines(x = 10:40, y = predict(gls.model))

# Plotting basis functions
plot(b.matrix, xlab = "")

# Plotting basis functions scaled to data
plot(b.matrix, xlab = "", ylim = c(0,9))

# Gathering knot placements
spline.attributes <- attributes(bs(10:40, df = 6))

internal.knots <- spline.attributes$knots

boundary.knots <- spline.attributes$Boundary.knots

# Plotting knot locations
plot(x = 10:40, y = data, ylab = "", xlab = "", pch = 19, col = "white")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")

# Plotting knot locations with basis functions
plot(b.matrix, xlab = "")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")

# Plotting knot locations on data
plot(x = 10:40, y = data, ylab = "", xlab = "", pch = 19, col = "black")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")

# Plotting basis matrix without a basis function in first knot interval
b.matrix.wo1 <- b.matrix[c(7:31),]
plot(b.matrix, xlab = "", col = "white")
for (i in 1:ncol(b.matrix.wo1)){
  x <- i
  lines(x = 10:40, y = c(rep(0,6),b.matrix.wo1[,x]), col = i)
}

```

##### Spline 1
```{r}
# We extract out the data used in the first knot
b.matrix.spline.1 <- matrix(c(b.matrix[1:8,]), nrow = 8, ncol = 6)

# Extracting spline coefficients
gls.spline.coef <- round(coef(gls.model))

# We extract our spline coefficients from TanCyo (ignoring the intercept coefficient)
gls.spline.coef.matrix <- matrix(gls.spline.coef[2:7], ncol = 1)

# We multiply our matrices to get our predicted values
cubic.spline.1 <- b.matrix.spline.1 %*% gls.spline.coef.matrix

# We add our intercept coefficient to our predicted values
cubic.spline.1 <- cubic.spline.1 + gls.spline.coef[1]

# Plotting to verify code ran correctly
plot(x = 10:17, y = c(cubic.spline.1), main = "Spline 1", pch = 19, col = "black", xlab = "", ylab = "")

# x-axis subset
x1 <- 10:17

# Fitting a cubic function to our predicted values
cubic.regression.1 <- lm(c(cubic.spline.1) ~ x1 + I(x1^2) + I(x1^3))

# Basis matrix reduction
b.matrix.wo1 <- b.matrix[c(9:31),]


plot(b.matrix, xlab = "", col = "white", ylim = c(0,5))
for (i in 1:ncol(b.matrix.wo1)){
  x <- i
  lines(x = 10:40, y = c(rep(0,8),b.matrix.wo1[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")

# Plotting with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,5))
for (i in 1:ncol(b.matrix.wo1)){
  x <- i
  lines(x = 10:40, y = c(rep(0,8),b.matrix.wo1[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")
```


##### Spline 2
```{r}
# We extract out the data used in the first knot
b.matrix.spline.2 <- matrix(c(b.matrix[9:16,]), nrow = 8, ncol = 6)

# Extracting spline coefficients
gls.spline.coef <- round(coef(gls.model))

# We extract our spline coefficients from TanCyo (ignoring the intercept coefficient)
gls.spline.coef.matrix <- matrix(gls.spline.coef[2:7], ncol = 1)

# We multiply our matrices to get our predicted values
cubic.spline.2 <- b.matrix.spline.2 %*% gls.spline.coef.matrix

# We add our intercept coefficient to our predicted values
cubic.spline.2 <- cubic.spline.2 + gls.spline.coef[1]

# Plotting to verify code ran correctly
plot(x = 18:25, y = c(cubic.spline.2), main = "Spline 2", pch = 19, col = "black", xlab = "", ylab = "")

# x-axis subset
x2 <- 18:25

# Fitting a cubic function to our predicted values
cubic.regression.2 <- lm(c(cubic.spline.2) ~ x2 + I(x2^2) + I(x2^3))

# Basis matrix reduction
b.matrix.wo2 <- b.matrix[c(17:31),]

plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:ncol(b.matrix.wo2)){
  x <- i
  lines(x = 10:40, y = c(rep(0,16),b.matrix.wo2[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")


# Plotting with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:ncol(b.matrix.wo2)){
  x <- i
  lines(x = 10:40, y = c(rep(0,16),b.matrix.wo2[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")
```

##### Spline 3
```{r}
# We extract out the data used in the first knot
b.matrix.spline.3 <- matrix(c(b.matrix[17:23,]), nrow = 7, ncol = 6)

# Extracting spline coefficients
gls.spline.coef <- round(coef(gls.model))

# We extract our spline coefficients from TanCyo (ignoring the intercept coefficient)
gls.spline.coef.matrix <- matrix(gls.spline.coef[2:7], ncol = 1)

# We multiply our matrices to get our predicted values
cubic.spline.3 <- b.matrix.spline.3 %*% gls.spline.coef.matrix

# We add our intercept coefficient to our predicted values
cubic.spline.3 <- cubic.spline.3 + gls.spline.coef[1]

# Plotting to verify code ran correctly
plot(x = 26:32, y = c(cubic.spline.3), main = "Spline 3", pch = 19, col = "black", xlab = "", ylab = "")

# x-axis subset
x3 <- 26:32

# Fitting a cubic function to our predicted values
cubic.regression.3 <- lm(c(cubic.spline.3) ~ x3 + I(x3^2) + I(x3^3))

# Basis matrix reduction
b.matrix.wo3 <- b.matrix[c(25:31),]

plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:ncol(b.matrix.wo3)){
  x <- i
  lines(x = 10:40, y = c(rep(0,24),b.matrix.wo3[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l")

# Plotting with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:ncol(b.matrix.wo3)){
  x <- i
  lines(x = 10:40, y = c(rep(0,24),b.matrix.wo3[,x]), col = i)
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")
```

##### Spline 4
```{r}
# We extract out the data used in the first knot
b.matrix.spline.4 <- matrix(c(b.matrix[24:31,]), nrow = 8, ncol = 6)

# Extracting spline coefficients
gls.spline.coef <- round(coef(gls.model))

# We extract our spline coefficients from TanCyo (ignoring the intercept coefficient)
gls.spline.coef.matrix <- matrix(gls.spline.coef[2:7], ncol = 1)

# We multiply our matrices to get our predicted values
cubic.spline.4 <- b.matrix.spline.4 %*% gls.spline.coef.matrix

# We add our intercept coefficient to our predicted values
cubic.spline.4 <- cubic.spline.4 + gls.spline.coef[1]

# Plotting to verify code ran correctly
plot(x = 33:40, y = c(cubic.spline.4), main = "Spline 4", pch = 19, col = "black", xlab = "", ylab = "")

# x-axis subset
x4 <- 33:40

# Fitting a cubic function to our predicted values
cubic.regression.4 <- lm(c(cubic.spline.4) ~ x4 + I(x4^2) + I(x4^3))

# Basis matrix reduction can be skipped as there are no more points to plot for each basis function

plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l")
points(x = 33:40, predict(cubic.regression.4), pch = 19, col = "orange3", type = "l")


# Plotting with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l")
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l")
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l")
points(x = 33:40, predict(cubic.regression.4), pch = 19, col = "orange3", type = "l")
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")
```

##### Connecting splines

```{r}
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
lines(x = 10:40, y = c(predict(cubic.regression.1),predict(cubic.regression.2),predict(cubic.regression.3),predict(cubic.regression.4)), col = "gold", lwd = 5)
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l", lwd = 5)
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l", lwd = 5)
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l", lwd = 5)
points(x = 33:40, predict(cubic.regression.4), pch = 19, col = "orange3", type = "l", lwd = 5)

# Plotting with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
lines(x = 10:40, y = c(predict(cubic.regression.1),predict(cubic.regression.2),predict(cubic.regression.3),predict(cubic.regression.4)), col = "gold", lwd = 5)
points(x = 10:17, predict(cubic.regression.1), pch = 19, col = "blue", type = "l", lwd = 5)
points(x = 18:25, predict(cubic.regression.2), pch = 19, col = "red", type = "l", lwd = 5)
points(x = 26:32, predict(cubic.regression.3), pch = 19, col = "green3", type = "l", lwd = 5)
points(x = 33:40, predict(cubic.regression.4), pch = 19, col = "orange3", type = "l", lwd = 5)
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")

# Plotting just total predicted curve
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
lines(x = 10:40, y = c(predict(cubic.regression.1),predict(cubic.regression.2),predict(cubic.regression.3),predict(cubic.regression.4)), col = "gold", lwd = 5)

# Plotting just total predicted curve with knot placements
plot(b.matrix, xlab = "", col = "white", ylim = c(0,9))
for (i in 1:6){
  x <- i
  lines(x = 10:40, y = c(rep(0,31)), col = "white")
}
lines(x = 10:40, y = c(predict(cubic.regression.1),predict(cubic.regression.2),predict(cubic.regression.3),predict(cubic.regression.4)), col = "gold", lwd = 5)
abline(v = boundary.knots[1], col = "purple4")
abline(v = boundary.knots[2], col = "purple4")
abline(v = internal.knots[1], col = "orange2")
abline(v = internal.knots[2], col = "orange2")
abline(v = internal.knots[3], col = "orange2")

```


#### Visual system plots

```{r}

summer_tanager_reflectance <- read_xlsx("C:\\Users\\proto\\Box\\Alfaro_Lab\\Museum_Hyperspec_Project\\Museum_setup_small\\tanager.xlsx", skip = 5)

summer_tanager_reflectance <- summer_tanager_reflectance[12:88]

summer_tanager_reflectance <- t(summer_tanager_reflectance)

summer_tanager_reflectance <- cbind(as.numeric(rownames(summer_tanager_reflectance)), summer_tanager_reflectance)


colnames(summer_tanager_reflectance) <- c("wl", "reflectance")

summer_tanager_reflectance <- as.rspec(summer_tanager_reflectance, interp = TRUE, lim = c(300,700))


plot(summer_tanager_reflectance)

summer_tanager <- readPNG("C:\\Users\\proto\\Box\\Alfaro_Lab\\Museum_Hyperspec_Project\\Museum_setup_small\\summer_tanager_ventral_11_2024-08-05_13-50-07_-removebg-preview.png")

plot(1:2, type = 'n')
rasterImage(summer_tanager, xleft = 1, xright = 1.4, ytop = 1.8, ybottom = 1, angle = 0)

human <- vismodel(summer_tanager_reflectance, visual = "cie10")
human_color <- colspace(human, space = "tri")
plot(human_color)

starling <- vismodel(summer_tanager_reflectance, visual = "star")
starling_color <- colspace(starling, space = "tri")
triplot(starling_color)

fly <- vismodel(summer_tanager_reflectance, visual = "drosophila")
fly_color <- colspace(fly, space = "tri")
plot(fly_color)

triplot_points <- rbind(fly_color, human_color)
triplot_points <- rbind(triplot_points, starling_color)

triplot(triplot_points, col = c("blue", "green","orange"))
legend(x = "topright",legend = c("fly","human", "starling"), fill = c("blue","green","orange"))
rasterImage(summer_tanager, xleft = 0.65, xright = 1.65, ytop = 0.7, ybottom = -0.3, angle = 0)


triplot(triplot_points, col = c("blue", "green","orange"))
legend(x = "topright",legend = c("fly","human", "starling"), fill = c("blue","green","orange"))
rasterImage(summer_tanager, xleft = -1, xright = 1, ytop = 1, ybottom = -1, angle = 0)


triplot(triplot_points, col = c("blue", "green","orange"))
legend(x = "topright",legend = c("fly","human", "starling"), fill = c("blue","green","orange"))
rasterImage(summer_tanager, xleft = 0.1, xright = 1.2, ytop = 0.65, ybottom = -0.2, angle = 0)
```


### Step 22: Extracting RGB values from hex code for BEAST


```{r}

tan_rgb_data <- NULL

red <- NULL
blue <- NULL
green <- NULL

for (i in 1:51){
  
  y <- i
  
  x <- as.character(names(spline_results)[i])
  
  x <- spline_results[[x]]
  
  x <- x$reflectance_rgb
  
  x <- col2rgb(x)
  
  red[i] <- x[1]
  
  green[i] <- x[2]
    
  blue[i] <- x[3]

}

tan_rgb_data <- rbind(red, green)
tan_rgb_data <- rbind(tan_rgb_data, blue)

tan_rgb_data <- t(tan_rgb_data)

tan_rgb_data <- cbind(c(as.character(names(spline_results))), tan_rgb_data)

colnames(tan_rgb_data) <- c("species", "red", "green", "blue")

tan_rgb_data <- data.frame(tan_rgb_data)

write_tsv(tan_rgb_data, "tanager_rgb_data.txt")


for (i in 1:51){
  
  print(which(tanagerTree$tip.label[i] == c((tan_rgb_data$species))))

  
  
}

name.check(tanagerTree, tan_rgb_data)


```


### Loading Root State Spline Coefficient Distributions from BEAST Output

Output from 12.2.24

Also note: Remove curly brackets from spline coefficients in text editor

```

root_state_coefficient_output <- read.delim("C:\\Users\\proto\\Box\\BEAST Output\\Spline_XML_Output_12.9.24\\test - Copy.log", comment.char="#")

root_state_coefficient_distributions <- strsplit(root_state_coefficient_output$spline_coefficients_BEAST, split = ",")

BEAST_coefficient_extraction <- function(output_data, basis_matrix){
  
storage <- NULL

distributions_list <- strsplit(output_data$spline_coefficients_BEAST, split = ",")

reflectance_data <- NULL

for (i in 1:dim(output_data)[1]){
  
  x <- c(distributions_list[[i]])
  
  storage <- rbind(storage, x)
  
  x <- as.numeric(x)
  
  coef_matrix <- matrix(x[2:39], nrow = 38, ncol = 1)
  
  root_reflectance <- basis_matrix %*% coef_matrix
  
  root_reflectance <- root_reflectance + x[1]
  
  reflectance_data <- cbind(reflectance_data, root_reflectance)
  
}

reflectance_data <- cbind(300:700, reflectance_data)

return(list(storage, reflectance_data))


}


tanager_spline_asr <- BEAST_coefficient_extraction(root_state_coefficient_output, bspline_matrix_bSpline)

asr_reflectance <- tanager_spline_asr[[2]]

colnames(asr_reflectance) <- c("wl", 1:((dim(asr_reflectance)[2])-1))

asr_reflectance <- procspec(asr_reflectance, fixneg = "zero")

colnames(asr_reflectance) <- c("wl", 1:((dim(asr_reflectance)[2])-1))

str(asr_reflectance)

asr_mean_reflectance <- NULL
asr_sd_reflectance <- NULL

for (i in 1:((dim(asr_reflectance)[1]))){
  
  x <- i
  
  asr_wl_reflectance <- unlist(asr_reflectance[x, -1])
  
  asr_mean_reflectance[i] <- mean(asr_wl_reflectance)
       
  asr_sd_reflectance[i] <- sd(asr_wl_reflectance)
  
}

plot(x= 300:700, y = asr_mean_reflectance, pch = 19,)

```


#### Comparing node #/positioning between BEAST and tanagerTree

```{r}

# Taxa order from BEAST. Placed alphabetically rather than leaf node placement
BEAST_species_order <- c("TanArg","TanArt","TanCal","TanCay","TanChi","TanChr","TanCuc","TanCya","TanCyc","TanCyo","TanCyp","TanCyv","TanDes","TanDow","TanFas","TanFlo","TanFuc","TanGut","TanGyr","TanHei","TanIct","TanIno","TanJoh","TanLab","TanLar","TanLav","TanMex","TanNic","TanNiv","TanPal","TanPar","TanPre","TanPun","TanRue","TanRuf","TanRuu","TanSch","TanSel","TanVar","TanVas","TanVel","TanVir","TanVit","TanXac","TanXag","ThrAbb","ThrCyp","ThrEpi","ThrOrn","ThrPal","ThrSay")

BEAST_species_order <- cbind(1:51, BEAST_species_order)

# Taxa order from tanagerTree. Placed based on the order (bottom to top) of tips of phylogenetic tree
tree_species_order <- tanagerTree$tip.label

tree_species_order <- cbind(1:51, tree_species_order)

tree_species_order <- data.frame(tree_species_order)

colnames(tree_species_order) <- c("tree_order", "species.2")

tree_species_order <- arrange(tree_species_order, tree_species_order$species.2)

species_order <- cbind(BEAST_species_order, tree_species_order)

species_order <- data.frame(species_order)

colnames(species_order) <- c("BEAST_placement", "species.1", "tree_order", "species.2")




```



### Basis matrix extraction

```{r}

for (i in 1:38){
  
  x <- i
  
  x <- bspline_matrix_bSpline[,x]
  
  x <- as.character(x)
  
  y <- paste("<attr id=basis.matrix.col.", i, sep = '')
  
  y <- paste(y, "value = ")
  
  x <- paste(x, sep = " ")
  
  y <- paste(y, x)
  
  
}




```




### mvMORPH ancestral state reconstruction

```{r}


# Storage vector
spline.data.mvgls <- NULL

# Data frame without a species column
spline.coef.data.mvgls <-spline_coef_data[,-1]

# for loop to turn our data frame into a numeric "vector"
# You do not want it to be a matrix or a data frame
for (i in 1:39){
    x<-i
    y<-spline.coef.data.mvgls[,x]
    spline.data.mvgls<-cbind(spline.data.mvgls,y)
}

# Adds rownames to our data "vector" to assign our coefficients to tip labels
rownames(spline.data.mvgls) <- names(spline_results)

# Creates a data list for the mvgls function
data.mvgls <- list(spline.data.mvgls=spline.data.mvgls)

# mvgls model 
# Formula defined as an intercept only model (no predictor variables)
fit_mvgls <- mvgls(spline.data.mvgls~1, data = data.mvgls, tree = tanagerTree, model = "BM")

# Ancestral state reconstruction of a mvgls object
asr.mvgls <- ancestral(fit_mvgls)

# Ancestral state reconstruction (mvgls) as a data frame
asr.mvgls.df <- data.frame(asr.mvgls)

# Adding coefficient names to columns of ASR (mvgls)
colnames(asr.mvgls.df) <- coefficient_names[2:40]

# Storage vector
asr.reflectance.mvgls <- NULL

# for loop plotting all of the reconstructed nodes
for (i in 1:nrow(asr.mvgls.df)){
  
  x <- i
  
  node.spline.coef.matrix <- matrix(unlist(c(asr.mvgls.df[x, 2:39])), nrow = 38, ncol = 1)
  
  reflectance.storage <- basis_spline_matrix %*% node.spline.coef.matrix
  
  reflectance.storage <- c(reflectance.storage)
  
  reflectance.storage <- reflectance.storage + asr.mvgls.df[x,1]
  
  asr.reflectance.mvgls <- cbind(asr.reflectance.mvgls, reflectance.storage)
  
}

colnames(asr.reflectance.mvgls) <- rownames(asr.mvgls)

for (i in 1:ncol(asr.reflectance.mvgls)){
  
  x <- i
  
  y <- as.character(colnames(asr.reflectance.mvgls)[i])
  
  rspec <- cbind(300:700, asr.reflectance.mvgls[,x])
  
  colnames(rspec) <- c("wl", "reflectance")
  
  rspec <- as.rspec(rspec)
  
  plot(rspec, main = paste(y, "ASR"), col = as.character(spec2rgb(procspec(rspec, fixneg = "zero"))), lwd = 5)
  
  
}


asr.mvgls

variances.asr.mvgls <- diag(fit_mvgls$sigma$Pinv)

names(variances.asr.mvgls) <- c("Intercept", as.character(1:38))

variance.label <- expression(paste(sigma^{2}))
# Save each spectra as an image
# Bar plot of the variance values, make look nice

par(mar= c(5.1,5.1,4.1,2.1))
barplot(variances.asr.mvgls, col = color_for_plots_V1, ylab = expression(paste("Variance", sep = " ", (sigma^{2}))), xlab = "Coefficients")
par(mar= c(5.1,4.1,4.1,2.1))

covariance.matrix <- fit_mvgls$sigma$Pinv

correlation.matrix <- cov2cor(covariance.matrix)

correlation.matrix.vector <- NULL
for (i in 1:39){
  
  x <- i
  
  storage <- c(correlation.matrix[,x])
  
  correlation.matrix.vector <- c(correlation.matrix.vector, storage)
  
}


c.m.names.x <- rep(coefficient_names[2:40], 39)
c.m.names.x <- factor(c.m.names.x, ordered = TRUE, levels = c(coefficient_names[2:40]))
correlation.matrix.heatmap <- cbind(correlation.matrix.vector, c.m.names.x)

c.m.names.y <- NULL
for (i in 2:40){
  
  x <- coefficient_names[i]
  
  storage <- rep(x, 39)
  
  c.m.names.y <- c(c.m.names.y, storage)
  
  
}

c.m.names.y <- factor(c.m.names.y, ordered = TRUE, levels = c(coefficient_names[2:40]))
correlation.matrix.heatmap <- cbind(correlation.matrix.heatmap, c.m.names.y)

correlation.matrix.heatmap <- data.frame(correlation.matrix.heatmap)

correlation.matrix.heatmap[,1] <- as.numeric(correlation.matrix.heatmap[,1])

ggplot(data = correlation.matrix.heatmap, aes(fill = correlation.matrix.vector, x = c.m.names.x, y = c.m.names.y)) + geom_tile(show.legend = TRUE) + scale_fill_gradient2(low = "blue", name = "Correlation",high = "orange", mid = "white")
# Plot the ancestral reflectance at the root, color each segment based on variance 

# Turn covariance matrix into a correlation matrix
# Visualize the strength of the correlation of the coefficients (heatmap)
# Create a plot that expresses the correlation 

# Take 1000 trees, extract root coefficients for 100, plot 100 spectra (alpha = 0.25 forexample)
```



### BEAST ancestral state reconstruction
```{r, message=FALSE}

load("C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\BEAST.trees.subset.RData")

root_annotator <- function(trees_file, coefficient_names){

  if (class(trees_file) != "multiPhylo"){
    print("This object is not a multiphylo object!")
  }
  
  else{
    
  root.annotations.df <- NULL
    
  tree.names <- NULL

  for (i in 1:length(trees_file)){
  
    tree.names[i] <- names(trees_file)[i]
  
    tree <- trees_file[[i]]
  
    root.annotations <- unlist(tree$root.annotation$spline_coefficients_BEAST)
  
    root.annotations.df <- rbind(root.annotations.df, root.annotations)
  
    }

  root.annotations.df <- data.frame(root.annotations.df)

  rownames(root.annotations.df) <- tree.names
  
  colnames(root.annotations.df) <- coefficient_names

  return(root.annotations.df)

}
}

BEAST.root.asr <- root_annotator(BEAST.trees.subset, coefficient_names[2:40])

head(BEAST.root.asr)

str(BEAST.root.asr)

spline.coef.to.reflectance <- function(spline.coef.matrix, basis_matrix, tree_names){

reflectance.df <- NULL

for (i in 1:dim(spline.coef.matrix)[1]){
  
  x <- i
  
  spline.coef <- matrix(c(unlist(spline.coef.matrix[x,2:39])), nrow = 38, ncol = 1)
  
  reflectance <- basis_matrix %*% spline.coef

  reflectance <- reflectance + spline.coef.matrix[x,1]
    
  reflectance.df <- cbind(reflectance.df, reflectance)
  
}

reflectance.df <- cbind(300:700, reflectance.df)

reflectance.df <- data.frame(reflectance.df)

colnames(reflectance.df) <- c("wl", tree_names)

return(reflectance.df)
}

BEAST.root.reflectance <- spline.coef.to.reflectance(BEAST.root.asr, bspline_matrix_bSpline, rownames(BEAST.root.asr))

BEAST.root.reflectance <- as.rspec(BEAST.root.reflectance)

BEAST.root.reflectance <- procspec(BEAST.root.reflectance, fixneg = "zero")


plot(x = BEAST.root.reflectance$wl, y = rep(100, 401), ylim = c(0,100), col = "white")
for (i in 2:101){

  x <- i
  
  rspec <- cbind(BEAST.root.reflectance$wl, BEAST.root.reflectance[,x])
  
  colnames(rspec) <- c("wl", "reflectance")
  
  rgb.color <- spec2rgb(as.rspec(rspec))
  
  rgb.color <- alpha(as.character(rgb.color), alpha = 0.25)
  
  lines(x = BEAST.root.reflectance$wl, y = BEAST.root.reflectance[,x], col = rgb.color, lwd = 3)
}
lines(x = 300:700, y = asr.reflectance.mvgls[,1], col = "black", lwd = 5)


```

