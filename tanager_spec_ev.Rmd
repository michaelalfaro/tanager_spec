---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)

```

### initialization

```{r}
suppressMessages({
  ddPath <- "C:/Users/proto/OneDrive/Documents/tanager_spec/tanager_spec/RefDataSpeciesSummary_MatchingMF/data"

  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  wl <- dat[[1]][, 1]
  dat <- sapply(dat, "[", -1)
  
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  specs <- procspec(specs, fixneg="zero")
  
  male_specs <- specs %>% select(!ends_with("f"))
  
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  rgb_colors <- spec2rgb(crown_data)
  names(rgb_colors) <- names(crown_data)[-1]
  
  head(crown_data)
})

```

### Step 1 Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}
treepath <- "C:/Users/proto/OneDrive/Documents/tanager_spec/tanager_spec/MCC_Tree_SpNames.nex"
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)


```




### Step 2 Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify
head(tanData_filtered)


```

### Step 3: Fitting Natural and Cubic Splines to the Tanager Data

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Natural and Cubic Splines to the Tanager Data

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, goodness-of-fit metrics, and RGB colors
fit_splines <- function(wl, reflectance) {
  # Fit natural cubic spline
  natural_spline_fit <- lm(reflectance ~ ns(wl, df = 5))
  
  # Fit cubic spline
  cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
  
  # Convert fitted splines to rspec and then to RGB hex codes
  natural_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(natural_spline_fit)), lim = c(300, 700))
  natural_rgb <- spec2rgb(natural_spline_rspec)
  
  cubic_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(cubic_spline_fit)), lim = c(300, 700))
  cubic_rgb <- spec2rgb(cubic_spline_rspec)
  
  # Extract coefficients
  natural_coef <- round(coef(natural_spline_fit), 2)
  cubic_coef <- round(coef(cubic_spline_fit), 2)
  
  # Calculate goodness-of-fit metrics
  natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
  cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
  
  natural_aic <- AIC(natural_spline_fit)
  cubic_aic <- AIC(cubic_spline_fit)
  
  return(list(
    natural_spline_fit = natural_spline_fit,
    cubic_spline_fit = cubic_spline_fit,
    natural_rgb = natural_rgb,
    cubic_rgb = cubic_rgb,
    natural_coef = natural_coef,
    cubic_coef = cubic_coef,
    natural_adj_r2 = natural_adj_r2,
    cubic_adj_r2 = cubic_adj_r2,
    natural_aic = natural_aic,
    cubic_aic = cubic_aic
  ))
}

# Apply the spline fitting function to each species
spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines(tanData_filtered$wl, reflectance)
})



```

Step 3b--making the species plots of natural and cubic spline

```{r}
plot_splines_with_metrics <- function(species_name, wl, reflectance, spline_results, rgb_colors) {
  result <- spline_results[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Natural Spline
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Natural Spline -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$natural_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("Adj R2:", round(result$natural_adj_r2, 3), "AIC:", round(result$natural_aic, 2)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Cubic Spline
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Spline -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance")
lines(wl, predict(result$cubic_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("Adj R2:", round(result$cubic_adj_r2, 3), "AIC:", round(result$cubic_aic, 2)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
}

for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}

pdf("natural_vs_cubic_splines_with_metrics.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], spline_results, rgb_colors)
}
dev.off()


```


### Step 4: Plotting Spline Fits and Original Data in the Markdown Document

```{r, message=FALSE, warning=FALSE}
### Step 4: Calculate Average Splines and Standard Deviation

# Calculate the maximum reflectance across all splines
max_reflectance <- max(sapply(spline_results, function(result) {
  max(predict(result$natural_spline_fit), predict(result$cubic_spline_fit))
}))

# Initialize vectors to store average splines and standard deviations
natural_spline_avg <- numeric(length(tanData_filtered$wl))
cubic_spline_avg <- numeric(length(tanData_filtered$wl))
natural_spline_sd <- numeric(length(tanData_filtered$wl))
cubic_spline_sd <- numeric(length(tanData_filtered$wl))

# Calculate averages
for (result in spline_results) {
  natural_pred <- predict(result$natural_spline_fit)
  cubic_pred <- predict(result$cubic_spline_fit)
  
  natural_spline_avg <- natural_spline_avg + natural_pred
  cubic_spline_avg <- cubic_spline_avg + cubic_pred
}

# Convert sums to averages
natural_spline_avg <- natural_spline_avg / length(spline_results)
cubic_spline_avg <- cubic_spline_avg / length(spline_results)

# Calculate standard deviations
for (result in spline_results) {
  natural_pred <- predict(result$natural_spline_fit)
  cubic_pred <- predict(result$cubic_spline_fit)
  
  natural_spline_sd <- natural_spline_sd + (natural_pred - natural_spline_avg)^2
  cubic_spline_sd <- cubic_spline_sd + (cubic_pred - cubic_spline_avg)^2
}

natural_spline_sd <- sqrt(natural_spline_sd / (length(spline_results) - 1))
cubic_spline_sd <- sqrt(cubic_spline_sd / (length(spline_results) - 1))

### Correct for negative values in the average splines

# Convert the average natural and cubic splines to rspec objects
natural_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = natural_spline_avg), lim = c(300, 700))
cubic_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = cubic_spline_avg), lim = c(300, 700))

# Correct any negative values in the rspec objects
natural_spline_rspec <- procspec(natural_spline_rspec, fixneg = "zero")
cubic_spline_rspec <- procspec(cubic_spline_rspec, fixneg = "zero")

# Convert corrected rspec objects to RGB hex codes
natural_spline_rgb <- spec2rgb(natural_spline_rspec)
cubic_spline_rgb <- spec2rgb(cubic_spline_rspec)

### Step 4a: Plot Average Splines with Confidence Intervals

# Create a plot for the average natural spline with confidence intervals
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Average Natural Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(natural_spline_avg + natural_spline_sd, rev(natural_spline_avg - natural_spline_sd)), 
        col = adjustcolor(natural_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Create a plot for the average cubic spline with confidence intervals
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Average Cubic Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(cubic_spline_avg + cubic_spline_sd, rev(cubic_spline_avg - cubic_spline_sd)), 
        col = adjustcolor(cubic_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

# Save the hotspot plots to a PDF
pdf("spline_hotspots.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))  # Plot both splines side by side

# Average Natural Spline with Hotspots in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Average Natural Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(natural_spline_avg + natural_spline_sd, rev(natural_spline_avg - natural_spline_sd)), 
        col = adjustcolor(natural_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Average Cubic Spline with Hotspots in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Average Cubic Spline with Variation Hotspots",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
polygon(c(tanData_filtered$wl, rev(tanData_filtered$wl)), 
        c(cubic_spline_avg + cubic_spline_sd, rev(cubic_spline_avg - cubic_spline_sd)), 
        col = adjustcolor(cubic_spline_rgb, alpha.f = 0.2), border = NA)
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()

### Step 4b: Plot Natural Spline Mean and Cubic Spline Mean with Species Overlaid

# Plot Natural Spline Mean with all species overlaid
par(mfrow = c(1, 2))

# Plot Natural Spline Mean with Species Overlaid
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$natural_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$natural_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline Mean with Species Overlaid
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$cubic_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$cubic_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

# Save the overlay plots to a PDF
pdf("spline_mean_with_species_overlay.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))

# Plot Natural Spline Mean with Species Overlaid in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$natural_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$natural_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline Mean with Species Overlaid in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline Mean with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (i in seq_along(spline_results)) {
  species_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[i]]$cubic_spline_fit)), lim = c(300, 700))
  species_rspec <- procspec(species_rspec, fixneg = "zero")  # Correct any negative values
  species_rgb <- spec2rgb(species_rspec)
  lines(tanData_filtered$wl, predict(spline_results[[i]]$cubic_spline_fit), col = adjustcolor(species_rgb, alpha.f = 0.3))
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()


```


### Step 4b Make a pair of plots of the natural and cubic spline where the spline is colored as a spec that is converted to its hsv value (make sure no negative values)

```{r, message=FALSE, warning=FALSE}
### Step 4b: Plot Natural Spline with Species Overlaid and Print to PDF

# Convert the natural spline to an rspec object and then to an RGB hex code
natural_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = natural_spline_avg), lim = c(300, 700))
natural_spline_rgb <- spec2rgb(natural_spline_rspec)

# Convert the cubic spline to an rspec object and then to an RGB hex code
cubic_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = cubic_spline_avg), lim = c(300, 700))
cubic_spline_rgb <- spec2rgb(cubic_spline_rspec)

# Plot the natural and cubic splines side by side in R Markdown
par(mfrow = c(1, 2))  # Arrange plots side by side

# Plot Natural Spline with Species Overlaid
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,  # Increased thickness
     main = "Natural Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))

# Loop through each species to plot their splines with slightly more visible transparency
for (species in names(spline_results)) {
  species_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$natural_spline_fit)), lim = c(300, 700))
  species_rgb <- spec2rgb(species_spline_rspec)
  
  # Adjust transparency to make species lines slightly more visible
  species_rgb_alpha <- adjustcolor(species_rgb, alpha.f = 0.4)  # Adjusted alpha for more visibility
  
  lines(tanData_filtered$wl, predict(spline_results[[species]]$natural_spline_fit), col = species_rgb_alpha)
}

# Re-plot the natural spline on top to ensure it stands out
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)  # Increased thickness

# Plot Cubic Spline with Species Overlaid
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,  # Increased thickness
     main = "Cubic Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))

# Loop through each species to plot their splines with slightly more visible transparency
for (species in names(spline_results)) {
  species_spline_rspec <- as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$cubic_spline_fit)), lim = c(300, 700))
  species_rgb <- spec2rgb(species_spline_rspec)
  
  # Adjust transparency to make species lines slightly more visible
  species_rgb_alpha <- adjustcolor(species_rgb, alpha.f = 0.4)  # Adjusted alpha for more visibility
  
  lines(tanData_filtered$wl, predict(spline_results[[species]]$cubic_spline_fit), col = species_rgb_alpha)
}

# Re-plot the cubic spline on top to ensure it stands out
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)  # Increased thickness

# Save the plots to a PDF as well
pdf("natural_and_cubic_splines_with_species_overlay.pdf", width = 12, height = 8)
par(mfrow = c(1, 2))  # Arrange plots side by side in the PDF

# Plot Natural Spline with Species Overlaid in PDF
plot(tanData_filtered$wl, natural_spline_avg, type = "l", col = natural_spline_rgb, lwd = 4,
     main = "Natural Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (species in names(spline_results)) {
  species_rgb_alpha <- adjustcolor(spec2rgb(as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$natural_spline_fit)), lim = c(300, 700))), alpha.f = 0.4)
  lines(tanData_filtered$wl, predict(spline_results[[species]]$natural_spline_fit), col = species_rgb_alpha)
}
lines(tanData_filtered$wl, natural_spline_avg, col = natural_spline_rgb, lwd = 4)

# Plot Cubic Spline with Species Overlaid in PDF
plot(tanData_filtered$wl, cubic_spline_avg, type = "l", col = cubic_spline_rgb, lwd = 4,
     main = "Cubic Spline with Species Overlaid",
     xlab = "Wavelength (nm)", ylab = "Reflectance", ylim = c(0, max_reflectance))
for (species in names(spline_results)) {
  species_rgb_alpha <- adjustcolor(spec2rgb(as.rspec(data.frame(wl = tanData_filtered$wl, reflectance = predict(spline_results[[species]]$cubic_spline_fit)), lim = c(300, 700))), alpha.f = 0.4)
  lines(tanData_filtered$wl, predict(spline_results[[species]]$cubic_spline_fit), col = species_rgb_alpha)
}
lines(tanData_filtered$wl, cubic_spline_avg, col = cubic_spline_rgb, lwd = 4)

dev.off()


```

### Step 5 Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}
# Open the PDF device
pdf("spline_fits_with_rgb_and_metrics.pdf", width = 12, height = 8)

# Set up the plotting area to show two plots per page
par(mfrow = c(1, 2))

# Loop over each species and plot the original data and spline fits side by side
for (species in names(spline_results)) {
  result <- spline_results[[species]]
  
  # Get the correct RGB color
  color <- rgb_colors[grep(species, names(rgb_colors))]
  
  # Plot original data and natural spline fit
  plot(tanData_filtered$wl, tanData_filtered[[species]], main = paste("Natural Spline Fit for", species),
       xlab = "Wavelength (nm)", ylab = "Reflectance", type = "o", col = color)
  lines(tanData_filtered$wl, predict(result$natural_spline_fit), col = "red", lwd = 2)
  mtext(paste("Adj R2:", round(result$natural_adj_r2, 3), "AIC:", round(result$natural_aic, 2)),
        side = 3, line = 0.5, cex = 0.7, col = "blue")
  
  # Plot original data and cubic spline fit
  plot(tanData_filtered$wl, tanData_filtered[[species]], main = paste("Cubic Spline Fit for", species),
       xlab = "Wavelength (nm)", ylab = "Reflectance", type = "o", col = color)
  lines(tanData_filtered$wl, predict(result$cubic_spline_fit), col = "green", lwd = 2)
  mtext(paste("Adj R2:", round(result$cubic_adj_r2, 3), "AIC:", round(result$cubic_aic, 2)),
        side = 3, line = 0.5, cex = 0.7, col = "blue")
}

# Close the PDF device
dev.off()

```


## Step 6 Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}
# Create the spline summary table with coefficients and goodness-of-fit metrics
spline_table <- data.frame(
  Species = names(spline_results),
  Natural_Spline_Coefficients = sapply(spline_results, function(x) paste(x$natural_coef, collapse = ", ")),
  Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
  Natural_Adj_R2 = sapply(spline_results, function(x) round(x$natural_adj_r2, 3)),
  Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
  Natural_AIC = sapply(spline_results, function(x) round(x$natural_aic, 2)),
  Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
)

# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

# Save the table as a CSV
write.csv(spline_table, "spline_summary_table.csv", row.names = FALSE)

# Fixing the PDF export by increasing the margins and adjusting the layout
pdf("spline_summary_table.pdf", width = 11, height = 8.5)
gridExtra::grid.table(spline_table, rows = NULL)
dev.off()

```


# Step 6b: Export Spline Data to CSV
```{r}
spline_export <- lapply(names(spline_results), function(species_name) {
  result <- spline_results[[species_name]]
  data.frame(
    Species = species_name,
    Wavelength = tanData_filtered$wl,
    Natural_Spline_Fitted = predict(result$natural_spline_fit),
    Cubic_Spline_Fitted = predict(result$cubic_spline_fit),
    Natural_Spline_Coefficients = paste(result$natural_coef, collapse = ", "),
    Cubic_Spline_Coefficients = paste(result$cubic_coef, collapse = ", "),
    Natural_Knots = paste(result$natural_knots, collapse = ", "),
    Cubic_Knots = paste(result$cubic_knots, collapse = ", ")
  )
})
# Combine all species data into one dataframe
spline_export_df <- do.call(rbind, spline_export)
# Save the data to a CSV file
write.csv(spline_export_df, "spline_data_for_reconstruction.csv", row.names = FALSE)
# Inform the user
cat("Spline data for reconstruction has been saved to 'spline_data_for_reconstruction.csv'.\n")
4:33
# Step 6c: Reconstruct and Plot Splines from CSV
spline_data <- read.csv("spline_data_for_reconstruction.csv")
# Function to plot the splines from the CSV data
plot_spline_from_csv <- function(species_name, spline_data) {
  species_data <- spline_data %>% filter(Species == species_name)
  # Plot Natural Spline
  plot(species_data$Wavelength, species_data$Natural_Spline_Fitted, type = "l", col = "blue", lwd = 2,
       main = paste("Natural Spline -", species_name),
       xlab = "Wavelength (nm)", ylab = "Reflectance")
  # Plot Cubic Spline
  lines(species_data$Wavelength, species_data$Cubic_Spline_Fitted, col = "red", lwd = 2)
  legend("topright", legend = c("Natural Spline", "Cubic Spline"), col = c("blue", "red"), lwd = 2)
}
# Plot all species
for (species_name in unique(spline_data$Species)) {
  plot_spline_from_csv(species_name, spline_data)
}

```

### Step 7 Save data objects for beast run


```{r, message=FALSE, warning=FALSE}

# Step 7: Save the Tanager Tree and Data as an R Data Object

# Save the tree, filtered spectral data, and spline results into an RData file
save(tanagerTree, tanData_filtered, spline_results, file = "tanager_analysis_results.RData")

# Inform the user that the data has been saved
cat("The Tanager tree, data, and spline results have been saved to 'tanager_analysis_results.RData'.\n")

```

### Step 8 Getting things ready for BEAST

```{r, message=FALSE, warning=FALSE}
# Export spline coefficients as a CSV file for BEAST
spline_traits <- data.frame(Species = names(spline_results))

# Add the coefficients as traits
for (i in 1:length(spline_results)) {
  spline_traits[i, "Natural_Spline_1"] = spline_results[[i]]$natural_coef[2]
  spline_traits[i, "Natural_Spline_2"] = spline_results[[i]]$natural_coef[3]
  spline_traits[i, "Natural_Spline_3"] = spline_results[[i]]$natural_coef[4]
  spline_traits[i, "Natural_Spline_4"] = spline_results[[i]]$natural_coef[5]
  spline_traits[i, "Cubic_Spline_1"] = spline_results[[i]]$cubic_coef[2]
  spline_traits[i, "Cubic_Spline_2"] = spline_results[[i]]$cubic_coef[3]
  spline_traits[i, "Cubic_Spline_3"] = spline_results[[i]]$cubic_coef[4]
}

# Save the spline traits to a CSV file
write.csv(spline_traits, "spline_coefficients_for_BEAST.csv", row.names = FALSE)

```

### Step 9 BEAST xml

not sure yet how to do this but here is the general approach....

Load Tree and Data:
Load your phylogenetic tree (e.g., tanagerTree) and the CSV file containing the traits.
Define the Traits:
In the XML file, define each spline coefficient as a separate trait. If you want to estimate a single evolutionary rate for all coefficients, you can define them as independent traits.
Model Specification:
For each trait, specify a Brownian motion model (bm).
If you want to treat the coefficients independently but estimate the same evolutionary rate for all, use a shared rate parameter across the traits.
Rate Estimation:
Define a hyperparameter for the rate of evolution and link it to all the traits.
Alternatively, run separate BEAST analyses for each trait if you want to estimate the rates independently.


```{xml}
<trait id="natural_spline_1" spec="RealParameter" dimension="N">
    <statefile name="state" startstate="true"/>
</trait>

<distribution id="prior" spec="util.CompoundDistribution">
    <distribution spec="beast.math.distributions.MRCAPrior" id="TMRCA">
        <tree topologies="$tanagerTree" spec="TreeLikelihood">
            <distribution spec="beast.evolution.likelihood.MG94Likelihood" id="treeModel">
                <data id="natural_spline_1.data" spec="beast.evolution.alignment.Alignment" dataType="continuous">
                    <sequence taxon="species1" totalcount="4" value="coeff1, coeff2, coeff3, coeff4"/>
                    <sequence taxon="species2" totalcount="4" value="coeff1, coeff2, coeff3, coeff4"/>
                </data>
            </distribution>
        </tree>
    </distribution>
</distribution>

<run id="mcmc" spec="MCMC">
    <state>
        <parameter id="rate" name="stateNode" dimension="1">0.1</parameter>
    </state>

    <posterior>
        <distribution id="posterior" spec="util.CompoundDistribution">
            <prior id="prior" spec="beast.math.distributions.MRCAPrior" tree="@treeModel">
                <normalPrior mean="0" stdev="1" name="distr"/>
            </prior>
            <likelihood id="likelihood" spec="util.CompoundDistribution">
                <distribution id="treeLikelihood" spec="TreeLikelihood">
                    <data id="alignment" spec="Alignment" dataType="continuous"/>
                    <siteModel id="SiteModel" spec="SiteModel" gammaCategoryCount="4">
                        <substitutionModel id="F81" spec="F81"/>
                    </siteModel>
                </distribution>
            </likelihood>
        </distribution>
    </posterior>
</run>
```
You will need to replicate this setup for each coefficient, ensuring that they either share or have independent rate parameters depending on your choice.

3. Run BEAST

Load the XML into BEAST: Once the XML is set up, load it into BEAST.
Run the Analysis: Start the analysis to estimate the evolutionary rates.
4. Post-Analysis

After the BEAST run completes, you can analyze the results using Tracer to check the estimated rates and other parameters.


# Nick's Work

```{r setup, include=FALSE}
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)

```


## Testing DF range in ns Function

```{message=FALSE, warning=FALSE}



# for loop to collect model details as we increase the degrees of freedom

for (i in 1:1){
  # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit natural cubic spline
    natural_spline_fit <- lm(reflectance ~ ns(wl, df = 1))
    
    # Fit cubic spline
    cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
    
    # Extract coefficients
    natural_coef <- round(coef(natural_spline_fit), 2)
    cubic_coef <- round(coef(cubic_spline_fit), 2)
    
    # Calculate goodness-of-fit metrics
    natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
    cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
    
    natural_aic <- AIC(natural_spline_fit)
    cubic_aic <- AIC(cubic_spline_fit)
    
    return(list(
      natural_spline_fit = natural_spline_fit,
      cubic_spline_fit = cubic_spline_fit,
      natural_coef = natural_coef,
      cubic_coef = cubic_coef,
      natural_adj_r2 = natural_adj_r2,
      cubic_adj_r2 = cubic_adj_r2,
      natural_aic = natural_aic,
      cubic_aic = cubic_aic
    ))
  }
  
  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })
  
  spline_table <- data.frame(
    Species = names(spline_results),
    Natural_Spline_Coefficients = sapply(spline_results, function(x) paste(x$natural_coef, collapse = ", ")),
    Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
    Natural_Adj_R2 = sapply(spline_results, function(x) round(x$natural_adj_r2, 3)),
    Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
    Natural_AIC = sapply(spline_results, function(x) round(x$natural_aic, 2)),
    Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
  )
  
  # Remove row names
  rownames(spline_table) <- NULL
  
  # Display the table in the document without row names
  kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
  # Save the table as a CSV
  write.csv(spline_table, "spline_df_summary_table.csv", row.names = FALSE)
  
# for loop up above sets up dataframe for the data from the for loop below to attach to  
  
  for (j in 2:41){
    # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
    fit_splines_df <- function(wl, reflectance) {
      # Fit natural cubic spline
      natural_spline_fit <- lm(reflectance ~ ns(wl, df = j))
      
      # Fit cubic spline
      cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
      
      # Extract coefficients
      natural_coef <- round(coef(natural_spline_fit), 2)
      cubic_coef <- round(coef(cubic_spline_fit), 2)
      
      # Calculate goodness-of-fit metrics
      natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
      cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
      
      natural_aic <- AIC(natural_spline_fit)
      cubic_aic <- AIC(cubic_spline_fit)
      
      return(list(
        natural_spline_fit = natural_spline_fit,
        cubic_spline_fit = cubic_spline_fit,
        natural_coef = natural_coef,
        cubic_coef = cubic_coef,
        natural_adj_r2 = natural_adj_r2,
        cubic_adj_r2 = cubic_adj_r2,
        natural_aic = natural_aic,
        cubic_aic = cubic_aic
      ))
    }
    
    # Apply the spline fitting function to each species
    spline_results_df <- lapply(tanData_filtered[-1], function(reflectance) {
      fit_splines_df(tanData_filtered$wl, reflectance)
    })
    
    spline_table_df <- data.frame(
      Species = names(spline_results_df),
      Natural_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$natural_coef, collapse = ", ")),
      Cubic_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$cubic_coef, collapse = ", ")),
      Natural_Adj_R2 = sapply(spline_results_df, function(x) round(x$natural_adj_r2, 3)),
      Cubic_Adj_R2 = sapply(spline_results_df, function(x) round(x$cubic_adj_r2, 3)),
      Natural_AIC = sapply(spline_results_df, function(x) round(x$natural_aic, 2)),
      Cubic_AIC = sapply(spline_results_df, function(x) round(x$cubic_aic, 2))
    )
    
    # Remove row names
    rownames(spline_table_df) <- NULL
    
    # Display the table in the document without row names
    kable(spline_table_df, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
      kable_styling(bootstrap_options = "striped", full_width = F)
    
    if (j == 2){
    spline_table_df_all <- rbind(spline_table, spline_table_df)
    rm(spline_table)}
    else if (j > 2){
    spline_table_df_all <- rbind(spline_table_df_all, spline_table_df)
    }
    # Save the table as a CSV
    write.csv(spline_table_df_all, "spline_df_summary_table.csv", row.names = FALSE)
    
   
    }
    
}
  

dev.off()
# ordering by species the collection of spline functions w/ varying df (3:41)
spline_table_df_ordered <- arrange(spline_table_df_all, spline_table_df_all$Species)

degrees_of_freedom <- rep(c(1:41),51)

spline_table_df_ordered <- cbind(degrees_of_freedom, spline_table_df_ordered)
  # Display the table in the document without row names
  kable(spline_table_df_ordered, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

```


## Testing DF range in bs Function

```{message=FALSE, warning=FALSE}



# for loop to collect model details as we increase the degrees of freedom

for (i in 1:1){
  # Function to fit a b spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit b cubic spline
    b_spline_fit <- lm(reflectance ~ bs(wl, df = 1))
    
    # Fit cubic spline
    cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
    
    # Extract coefficients
    b_coef <- round(coef(b_spline_fit), 2)
    cubic_coef <- round(coef(cubic_spline_fit), 2)
    
    # Calculate goodness-of-fit metrics
    b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
    cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
    
    b_aic <- AIC(b_spline_fit)
    cubic_aic <- AIC(cubic_spline_fit)
    
    return(list(
      b_spline_fit = b_spline_fit,
      cubic_spline_fit = cubic_spline_fit,
      b_coef = b_coef,
      cubic_coef = cubic_coef,
      b_adj_r2 = b_adj_r2,
      cubic_adj_r2 = cubic_adj_r2,
      b_aic = b_aic,
      cubic_aic = cubic_aic
    ))
  }
  
  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })
  
  spline_table <- data.frame(
    Species = names(spline_results),
    b_Spline_Coefficients = sapply(spline_results, function(x) paste(x$b_coef, collapse = ", ")),
    Cubic_Spline_Coefficients = sapply(spline_results, function(x) paste(x$cubic_coef, collapse = ", ")),
    b_Adj_R2 = sapply(spline_results, function(x) round(x$b_adj_r2, 3)),
    Cubic_Adj_R2 = sapply(spline_results, function(x) round(x$cubic_adj_r2, 3)),
    b_AIC = sapply(spline_results, function(x) round(x$b_aic, 2)),
    Cubic_AIC = sapply(spline_results, function(x) round(x$cubic_aic, 2))
  )
  
  # Remove row names
  rownames(spline_table) <- NULL
  
  # Display the table in the document without row names
  kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
  # Save the table as a CSV
  write.csv(spline_table, "spline_df_summary_table.csv", row.names = FALSE)
  
# for loop up above sets up dataframe for the data from the for loop below to attach to  
  
  for (j in 2:41){
    # Function to fit a b spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
    fit_splines_df <- function(wl, reflectance) {
      # Fit b cubic spline
      b_spline_fit <- lm(reflectance ~ bs(wl, df = j))
      
      # Fit cubic spline
      cubic_spline_fit <- lm(reflectance ~ poly(wl, 3, raw = TRUE))
      
      # Extract coefficients
      b_coef <- round(coef(b_spline_fit), 2)
      cubic_coef <- round(coef(cubic_spline_fit), 2)
      
      # Calculate goodness-of-fit metrics
      b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
      cubic_adj_r2 <- summary(cubic_spline_fit)$adj.r.squared
      
      b_aic <- AIC(b_spline_fit)
      cubic_aic <- AIC(cubic_spline_fit)
      
      return(list(
        b_spline_fit = b_spline_fit,
        cubic_spline_fit = cubic_spline_fit,
        b_coef = b_coef,
        cubic_coef = cubic_coef,
        b_adj_r2 = b_adj_r2,
        cubic_adj_r2 = cubic_adj_r2,
        b_aic = b_aic,
        cubic_aic = cubic_aic
      ))
    }
    
    # Apply the spline fitting function to each species
    spline_results_df <- lapply(tanData_filtered[-1], function(reflectance) {
      fit_splines_df(tanData_filtered$wl, reflectance)
    })
    
    spline_table_df <- data.frame(
      Species = names(spline_results_df),
      b_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$b_coef, collapse = ", ")),
      Cubic_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$cubic_coef, collapse = ", ")),
      b_Adj_R2 = sapply(spline_results_df, function(x) round(x$b_adj_r2, 3)),
      Cubic_Adj_R2 = sapply(spline_results_df, function(x) round(x$cubic_adj_r2, 3)),
      b_AIC = sapply(spline_results_df, function(x) round(x$b_aic, 2)),
      Cubic_AIC = sapply(spline_results_df, function(x) round(x$cubic_aic, 2))
    )
    
    # Remove row names
    rownames(spline_table_df) <- NULL
    
    # Display the table in the document without row names
    kable(spline_table_df, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
      kable_styling(bootstrap_options = "striped", full_width = F)
    
    if (j == 2){
    spline_table_df_all <- rbind(spline_table, spline_table_df)
    rm(spline_table)}
    else if (j > 2){
    spline_table_df_all <- rbind(spline_table_df_all, spline_table_df)
    }
    # Save the table as a CSV
    write.csv(spline_table_df_all, "spline_df_summary_table.csv", row.names = FALSE)
    
   
    }
    
}
  

dev.off()
# ordering by species the collection of spline functions w/ varying df (3:41)
spline_table_df_ordered <- arrange(spline_table_df_all, spline_table_df_all$Species)

degrees_of_freedom <- rep(c(1:41),51)

spline_table_df_ordered <- cbind(degrees_of_freedom, spline_table_df_ordered)
  # Display the table in the document without row names
  kable(spline_table_df_ordered, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

```



## Comparing results between ns and bs functions

```{message=FALSE, warning=FALSE}



# for loop to collect model details as we increase the degrees of freedom

for (i in 1:1){
  # Function to fit a natural spline and a b spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit natural b spline
    natural_spline_fit <- lm(reflectance ~ ns(wl, df = 1))
    
    # Fit b spline
    b_spline_fit <- lm(reflectance ~ bs(wl, df = 1))
    
    # Extract coefficients
    natural_coef <- round(coef(natural_spline_fit), 2)
    b_coef <- round(coef(b_spline_fit), 2)
    
    # Calculate goodness-of-fit metrics
    natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
    b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
    
    natural_aic <- AIC(natural_spline_fit)
    b_aic <- AIC(b_spline_fit)
    
    return(list(
      natural_spline_fit = natural_spline_fit,
      b_spline_fit = b_spline_fit,
      natural_coef = natural_coef,
      b_coef = b_coef,
      natural_adj_r2 = natural_adj_r2,
      b_adj_r2 = b_adj_r2,
      natural_aic = natural_aic,
      b_aic = b_aic
    ))
  }
  
  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })
  
  spline_table <- data.frame(
    Species = names(spline_results),
    Natural_Spline_Coefficients = sapply(spline_results, function(x) paste(x$natural_coef, collapse = ", ")),
    b_Spline_Coefficients = sapply(spline_results, function(x) paste(x$b_coef, collapse = ", ")),
    Natural_Adj_R2 = sapply(spline_results, function(x) round(x$natural_adj_r2, 3)),
    b_Adj_R2 = sapply(spline_results, function(x) round(x$b_adj_r2, 3)),
    Natural_AIC = sapply(spline_results, function(x) round(x$natural_aic, 2)),
    b_AIC = sapply(spline_results, function(x) round(x$b_aic, 2))
  )
  
  # Remove row names
  rownames(spline_table) <- NULL
  
  # Display the table in the document without row names
  kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
  # Save the table as a CSV
  write.csv(spline_table, "spline_df_summary_table.csv", row.names = FALSE)
  
# for loop up above sets up dataframe for the data from the for loop below to attach to  
  
  for (j in 2:41){
    # Function to fit a natural spline and a b spline, returning the models, coefficients, and goodness-of-fit metrics
    fit_splines_df <- function(wl, reflectance) {
      # Fit natural b spline
      natural_spline_fit <- lm(reflectance ~ ns(wl, df = j))
      
      # Fit b spline
      b_spline_fit <- lm(reflectance ~ ns(wl, df = j))
      
      # Extract coefficients
      natural_coef <- round(coef(natural_spline_fit), 2)
      b_coef <- round(coef(b_spline_fit), 2)
      
      # Calculate goodness-of-fit metrics
      natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
      b_adj_r2 <- summary(b_spline_fit)$adj.r.squared
      
      natural_aic <- AIC(natural_spline_fit)
      b_aic <- AIC(b_spline_fit)
      
      return(list(
        natural_spline_fit = natural_spline_fit,
        b_spline_fit = b_spline_fit,
        natural_coef = natural_coef,
        b_coef = b_coef,
        natural_adj_r2 = natural_adj_r2,
        b_adj_r2 = b_adj_r2,
        natural_aic = natural_aic,
        b_aic = b_aic
      ))
    }
    
    # Apply the spline fitting function to each species
    spline_results_df <- lapply(tanData_filtered[-1], function(reflectance) {
      fit_splines_df(tanData_filtered$wl, reflectance)
    })
    
    spline_table_df <- data.frame(
      Species = names(spline_results_df),
      Natural_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$natural_coef, collapse = ", ")),
      b_Spline_Coefficients = sapply(spline_results_df, function(x) paste(x$b_coef, collapse = ", ")),
      Natural_Adj_R2 = sapply(spline_results_df, function(x) round(x$natural_adj_r2, 3)),
      b_Adj_R2 = sapply(spline_results_df, function(x) round(x$b_adj_r2, 3)),
      Natural_AIC = sapply(spline_results_df, function(x) round(x$natural_aic, 2)),
      b_AIC = sapply(spline_results_df, function(x) round(x$b_aic, 2))
    )
    
    # Remove row names
    rownames(spline_table_df) <- NULL
    
    # Display the table in the document without row names
    kable(spline_table_df, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
      kable_styling(bootstrap_options = "striped", full_width = F)
    
    if (j == 2){
    spline_table_df_all <- rbind(spline_table, spline_table_df)
    rm(spline_table)}
    else if (j > 2){
    spline_table_df_all <- rbind(spline_table_df_all, spline_table_df)
    }
    # Save the table as a CSV
    write.csv(spline_table_df_all, "spline_df_summary_table.csv", row.names = FALSE)
    
   
    }
    
}
  

dev.off()
# ordering by species the collection of spline functions w/ varying df (3:41)
spline_table_df_ordered <- arrange(spline_table_df_all, spline_table_df_all$Species)

degrees_of_freedom <- rep(c(1:41),51)

spline_table_df_ordered <- cbind(degrees_of_freedom, spline_table_df_ordered)
  # Display the table in the document without row names
  kable(spline_table_df_ordered, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

```




## Knot placement comparison
```{r}
# NOTE: Run chunks initialization through Step 3 if working on this chunk



# function that records spline data
# records degree of function, # of internal and boundary knots and their placement
natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = 5)

  natural_spline_fit_data <- attributes(natural_spline)
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots
  ))
    
}

# applies the above function to tanager dataset
natural_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  natural_spline_data(tanData_filtered$wl, reflectance)
}
)


# Determination of the boundary knots and that their location is uniform for each species

# Data frame of the data
internal_knots_placement <- NULL

# Vector to store temporary data from for loop for the data frame
placeholder_vector <- NULL

# For loop that gathers the natural spline data
for (species_name in names(spline_results)){
  placeholder_vector <- natural_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}

# Converts the data into a data frame and applies species' names to the rows
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)

# Verification that internal knot placement is uniform

# Vector that captures the df used in for the natural spline
dimensions <- dim(internal_knots_placement)

# Vector that holds the knot placements
knots_vector <- NA

# For loop that turns the data frame into a vector
# Uses dimensions[2] for versatility (can be used for any df)
for (i in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,i])
  knots_vector <- c(knots_vector,x)
}

# NA omission
knots_vector <- na.omit(knots_vector)

# Visualization that data is uniform
hist(knots_vector, main = "Internal Knots Placement for Each Species", col = "yellow",
     ylab = "Frequency", xlab = "Wavelength (nm)")

# Further confirmation using logical vectors

# Turn the knots vector into a data frame to use count function
knots_dataframe <- data.frame(knots_vector)

# Counts the # of values for each knot's wavelength placement 
knots_counts <- knots_dataframe %>% count(knots_vector)

# # of species in our data
# Each wavelength should appear this amount of times if the knot placement is uniform
length(names(spline_results))

# For loop to verify that each wavelength appears 51 times
# If so, we should see 4 TRUEs as the output
for (i in 1:dimensions[2]){
  print(length(names(spline_results)) == knots_counts[i,2])
}


# For loop that looks at the degrees of freedom from 2:42
# Presently, there is a section for graphing each outcome but does not use space
# efficiently. Still a work in progress. The rest works as intended
for (i in 2:41){
  natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = i)

  natural_spline_fit_data <- attributes(natural_spline)
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots
  ))
    
}

natural_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  natural_spline_data(tanData_filtered$wl, reflectance)
}
)


internal_knots_placement <- NULL
placeholder_vector <- NULL
for (species_name in names(spline_results)){
  placeholder_vector <- natural_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)
head(internal_knots_placement)


par(mfrow=c(2,2))
dimensions <- dim(internal_knots_placement)
knots_vector <- NA
for (j in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,j])
  knots_vector <- c(knots_vector,x)
  }
knots_vector <- na.omit(knots_vector)

#hist(knots_vector, main = "Internal Knots Placement", col = "yellow",
#     ylab = "Frequency", xlab = "Wavelength (nm)", breaks = seq(300,700, length.out = #i), right = TRUE)


knots_dataframe <- data.frame(knots_vector)
knots_counts <- knots_dataframe %>% count(knots_vector)


# Created a system to verify each case (# of df) has uniform internal knot placement
# that does not lead to hundreds of TRUEs in the output

# Check vector that is the size of df
checker <- rep(NA, dimensions[2])

# For loop that checks if the length of each knot placement is equivalent to the # of     species
for (k in 1:dimensions[2]){
  if (length(names(spline_results)) != knots_counts[k,2]){
  checker[k] <- FALSE
  }
  
  if (length(names(spline_results)) == knots_counts[k,2]){
  checker[k] <- TRUE
  }

  }


# For loop to reduce the size of checker vector and further verify that all values are    TRUE
for (k in 1:dimensions[2]){
  if (checker[k] == TRUE){
    checker[k] <- NA
  }
}

# Removes all NA values
checker <- na.omit(checker)

# If all values are removed, then all knot placements are uniform
# Prints a singular output for each df case rather than df outputs
for (i in 1:1){
  if (length(checker) == 0){
    print("Knot Placements are Uniform")
  }
}


par(mfrow=c(1,1))

}

```



```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Natural and B Splines to the Tanager Data

# Function to fit a natural spline and a B Spline, returning the models, coefficients, goodness-of-fit metrics, and RGB colors
fit_splines <- function(wl, reflectance) {
  # Fit natural B Spline
  natural_spline_fit <- lm(reflectance ~ ns(wl, df = 5))
  
  # Fit B Spline
  b_spline_fit <- lm(reflectance ~ bs(wl, df = 5, Boundary.knots = c(300,700)))
  
  # Convert fitted splines to rspec and then to RGB hex codes
  natural_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(natural_spline_fit)), lim = c(300, 700))
  natural_rgb <- spec2rgb(natural_spline_rspec)
  
  b_spline_rspec <- as.rspec(data.frame(wl = wl, reflectance = predict(b_spline_fit)), lim = c(300, 700))
  quartic_rgb <- spec2rgb(b_spline_rspec)
  
  # Extract coefficients
  natural_coef <- round(coef(natural_spline_fit), 2)
  quartic_coef <- round(coef(b_spline_fit), 2)
  
  # Calculate goodness-of-fit metrics
  natural_adj_r2 <- summary(natural_spline_fit)$adj.r.squared
  quartic_adj_r2 <- summary(b_spline_fit)$adj.r.squared
  
  natural_aic <- AIC(natural_spline_fit)
  quartic_aic <- AIC(b_spline_fit)
  
  return(list(
    natural_spline_fit = natural_spline_fit,
    b_spline_fit = b_spline_fit,
    natural_rgb = natural_rgb,
    quartic_rgb = quartic_rgb,
    natural_coef = natural_coef,
    quartic_coef = quartic_coef,
    natural_adj_r2 = natural_adj_r2,
    quartic_adj_r2 = quartic_adj_r2,
    natural_aic = natural_aic,
    quartic_aic = quartic_aic
  ))
}

# Apply the spline fitting function to each species
spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
  fit_splines(tanData_filtered$wl, reflectance)
})


pdf(file = "Internal Knot Placement Uniformity Verification", width = 8, height = 12,paper = "letter", )
for (i in 2:41){
  natural_spline_data <- function(wl, reflectance){
  
  natural_spline <- ns(wl, df = i)

  natural_spline_fit_data <- attributes(natural_spline)
  
  return(list(
    degree = natural_spline_fit_data$degree,
    internal_knots = natural_spline_fit_data$knots,
    boundary_knots = natural_spline_fit_data$Boundary.knots
  ))
    
}

natural_spline_results <- lapply(tanData_filtered[-1], function(reflectance){
  natural_spline_data(tanData_filtered$wl, reflectance)
}
)


internal_knots_placement <- NULL
placeholder_vector <- NULL
for (species_name in names(spline_results)){
  placeholder_vector <- natural_spline_results[[species_name]]
  knot_placement <- placeholder_vector$internal_knots
  internal_knots_placement <- rbind(internal_knots_placement, knot_placement)
}
internal_knots_placement <- data.frame(internal_knots_placement)
rownames(internal_knots_placement) <- names(spline_results)


dimensions <- dim(internal_knots_placement)
knots_vector <- NA
for (j in 1:dimensions[2]){
  x <- as.numeric(internal_knots_placement[,j])
  knots_vector <- c(knots_vector,x)
  }
knots_vector <- na.omit(knots_vector)


hist(knots_vector, main = "Internal Knots Placement", col = i,
    ylab = "Frequency", xlab = "Wavelength (nm)", breaks = seq(300,700, length.out = i), right = TRUE)
}
dev.off()
dev.off()

```

# AIC and R^2 distributions
```{r, message = FALSE, warning=FALSE}
# Run everything through chunk Step 6



model_scoring <- spline_table[,c(1,4:7)]

model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Preferred_Model = min(c(Natural_AIC, Cubic_AIC)))

preferred_model_name <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,6] == model_scoring[i,4]){
    preferred_model_name[i] <- 0
  }
  else if (model_scoring[i,6] == model_scoring[i,5]){
    preferred_model_name[i] <- 1
  }
  else if (model_scoring[i,6] == model_scoring[i,5] & model_scoring[i,6] == model_scoring[i,4]){
    preferred_model_name[i] <- 2
  }
    }

model_scoring <- cbind(model_scoring, preferred_model_name)
column_names <- colnames(model_scoring)
column_names[7] <- "Preferred_Model_Name"
colnames(model_scoring) <- column_names

model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 0] <- "Natural"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 1] <- "Cubic"
model_scoring$Preferred_Model_Name[model_scoring$Preferred_Model_Name == 2] <- "Either"


ggplot(data = model_scoring, aes(x = Natural_AIC, fill = Preferred_Model_Name)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")


model_scoring <- model_scoring %>% 
  group_by(Species) %>%
  mutate(Best_Fit = max(c(Natural_Adj_R2, Cubic_Adj_R2)))

best_fit_model <- rep(NA, length(model_scoring$Species))
for (i in 1:length(model_scoring$Species)){
  if (model_scoring[i,8] == model_scoring[i,2]){
    best_fit_model[i] <- 0
  }
  else if (model_scoring[i,8] == model_scoring[i,3]){
    best_fit_model[i] <- 1
  }
  else if (model_scoring[i,8] == model_scoring[i,2] & model_scoring[i,3] == model_scoring[i,8]){
    best_fit_model[i] <- 2
  }
    }


model_scoring <- cbind(model_scoring, best_fit_model)
column_names <- colnames(model_scoring)
column_names[9] <- "Model_of_Best_Fit"
colnames(model_scoring) <- column_names

model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 0] <- "Natural"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 1] <- "Cubic"
model_scoring$Model_of_Best_Fit[model_scoring$Model_of_Best_Fit == 2] <- "Either"


ggplot(data = model_scoring, aes(x = Best_Fit, fill = Model_of_Best_Fit)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")





par(mfrow=c(1,2))

ggplot(data = model_scoring, aes(x = Best_Fit, fill = Model_of_Best_Fit)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")
ggplot(data = model_scoring, aes(x = Natural_AIC, fill = Preferred_Model_Name)) + geom_histogram() + scale_fill_brewer(palette = "Spectral")
hist(spline_table$Natural_Adj_R2, breaks = seq(0,1, length.out = 50))
hist(spline_table$Cubic_Adj_R2, breaks = seq(0,1, length.out = 50))
par(mfrow=c(2,1))



hist(spline_table$Natural_AIC, breaks = seq(min(spline_table$Natural_AIC),max(spline_table$Natural_AIC), length.out = 50))
hist(spline_table$Cubic_AIC, breaks = seq(min(spline_table$Cubic_AIC),max(spline_table$Cubic_AIC), length.out = 50))
par(mfrow=c(1,1))

```

