---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---

### Libraries
```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(nlme)
library(splines2)
```


### Step 1: Loading Reflectance Data

```{r}


suppressMessages({
  # File pathway linking to the reflectance data for Thraupidae specimens on laptop
  ddPath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\RefDataSpeciesSummary_MatchingMF\\data"
  
  # File pathway linking to the reflectance data for Thraupidae specimens on PC
  #ddPath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\RefDataSpeciesSummary_MatchingMF"

  # Reads in all of .csv files
  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  # Extracts all of the wavelengths and turns it into a vector
  wl <- dat[[1]][, 1]
  # Removes the wavelength column from each of the species' data frames
  dat <- sapply(dat, "[", -1)
  
  # Takes the reflectance data from each patch available for each species 
  # Combines reflectance data with wavelength vector ranging from 300-700 nm
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  # Turns all negative reflectance values in data frame to 0
  specs <- procspec(specs, fixneg="zero")
  
  # Creates a data frame with just male specimens
  male_specs <- specs %>% select(!ends_with("f"))
  
  # Creates a data frame from the male specimen data frame using only 
  # the crown patch of the bird
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  # Finds the rgb hex code for each of the crown patches
  rgb_colors <- spec2rgb(crown_data)
  # Adds names of the species to each hex color code
  names(rgb_colors) <- names(crown_data)[-1]
  
  # Verifies that data frame has been created correctly
  head(crown_data)
})


```



### Step 2: Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}

# File pathway linking to the Thraupidae tree on laptop
treepath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# File pathway linking to the Thraupidae tree on PC
#treepath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# Reads Thraupidae tree into R
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)

# Creates a NEXUS tree file into working directory
write.nexus(tanagerTree, file = "tanagerTree.NEXUS")
```



### Step 3: Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify data frame created correctly
head(tanData_filtered)

# Verifies that there are 0 species in data frame that should not be there
(names(tanData_filtered[-1]) == tanager_species)

# Verifies that there are not any species have not been added to data frame
length(names(tanData_filtered[-1])) == length(tanager_species)


```



### Step 4: Fitting Cubic Splines to the Tanager Reflectance and Log-Transformed Reflectance Data

Website that explains what splines are: https://community.jmp.com/t5/JMPer-Cable/Understanding-cubic-splines/ba-p/39511

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Cubic Splines to Tanager reflectance data

 # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 38 degrees of freedom (35 knots)
    # We use gls instead of lm, as our error structure fails the independence assumption
    # corAR1 was the error structure recommended for us to use
    # When using the corAR1 function, the argument value pertains to the type of autocorrelation present in the
    # corAR1 autocorrelation structure (at any given point, we only care about the autocorrelation of the next
    # surrounding point {x, x+1}).
    # For corAR1, I leave the 'value' argument at 0, given that it does not change any of the coefficient values
    # or the model score values. I will note that the error structure performs better (+ values) 
    # and worse (- values) at non-zero values, although I am unsure if this has any noteworthy
    # benefits to optimize. I need to talk to Professor Marc Suchard to clarify if leaving
    # it at the default of zero is acceptable.
    # With the form argument, I used form = ~ 1, form = ~ 300:700, and form = ~ wl,
    # and each produced identical results, so I will stick with the default of 
    # form = ~ 1 unless told otherwise.
    # For the final argument ('fixed'), fixed = TRUE produces lower residual standard
    # error values, but the model score performs lower than when fixed = FALSE.
    # I think this another question that needs to be asked as to which is better,
    # but for now, I will keep the default as fixed = FALSE.
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 38), correlation = 
                                          corAR1(form = ~ 1))

    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    # It is important to note that when working with trait data, we want to 
    # use the same basis matrix to preserve the same "trait space" (need to clarify
    # if this the correct thinking) between species. Thus, we make sure to keep the
    # same range of wavelength when proceeding forward (300-700 nm).
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC

    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC

    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      reflectance_coef = reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines_log <- function(wl, reflectance) {

    # Fit cubic spline to log-transformed reflectance values with 38 degrees of freedom (35 knots)
    cubic_spline_fit_log_reflectance <- gls((reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC

    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_log_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      log_reflectance_coef = log_reflectance_coef,
      log_reflectance_AIC = log_reflectance_AIC,
      log_reflectance_BIC = log_reflectance_BIC,
      log_reflectance_logLik = log_reflectance_logLik,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  
  # Here we need to make a separate data frame for our log-transformed data
  # This is to convert any values less than 1 to 1 to avoid Inf/NaN errors during 
  # our log-transformation of the reflectance data

  # Creates a separate data frame for only log-transformed data
  tanlogData_filtered <- tanData_filtered
  
  # Nested for loop to turn all data points < 1 into 1 to prevent any Inf/NaN errors
  for (i in 2:52){
    y <- as.numeric(i)
    for (j in 1:401){
      x <- as.numeric(j)
      matrix_position <- tanlogData_filtered[x,y]
      if (tanlogData_filtered[x,y] < 1){
        tanlogData_filtered[x,y] <- 1
      }
       else if (tanlogData_filtered[x,y] >= 1){
        tanlogData_filtered[x,y] <- matrix_position
       }
    }
}

  
  # This log-transforms every value in our data frame
  tanlogData_filtered <- log(tanlogData_filtered)
  # This converts our wavelength data back to standard values
  # (300-700 nm)
  tanlogData_filtered$wl <- exp(tanlogData_filtered$wl)

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })

# Applies our spline fitting function to our log-transformed reflectance data for
# each species
  spline_results_log <- lapply(tanlogData_filtered[-1], function(reflectance) {
    fit_splines_log(tanlogData_filtered$wl, reflectance)
  })
  
```




# Step 5: Species plots of splines on refl. and log refl. data

```{r}

# Function that plots the splines from each dataset for all species
plot_splines_with_metrics <- function(species_name, wl, reflectance, log_reflectance, spline_results, spline_results_log, rgb_colors) {
  
  # Extracts a single species spline results from each dataset list
  result <- spline_results[[species_name]]
  log_result <- spline_results_log[[species_name]]
  
  par(mfrow = c(1, 2))
  
  # Plots Cubic Splines for Reflectance Data with model scores
plot(wl, reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(wl, predict(result$reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(result$reflectance_AIC, 3), "BIC:", round(result$reflectance_BIC, 2), "logLik:", round(result$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

# Plots Cubic Splines for log Reflectance data with model scores
plot(wl, log_reflectance, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Spline (log Refl.) -", species_name),
     xlab = "Wavelength (nm)", ylab = "log Reflectance (%)")
lines(wl, predict(log_result$log_reflectance_spline_fit), col = rgb_colors[[species_name]], lwd = 2)
mtext(paste("AIC:", round(log_result$log_reflectance_AIC, 3), "BIC:", round(log_result$log_reflectance_BIC, 2), "logLik:", round(log_result$log_reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")
}

# Takes above function and uses a for loop to get every species' spline results plotted
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}

# Takes the above plots and puts them onto a pdf
pdf("cubic_splines_refl&logrefl_with_metrics.pdf", width = 12, height = 8)
for (species_name in names(spline_results)) {
  plot_splines_with_metrics(species_name, tanData_filtered$wl, tanData_filtered[[species_name]], tanlogData_filtered[[species_name]], spline_results, spline_results_log, rgb_colors)
}
dev.off()


```


## Step 6: Print a Summary Table of Spline Fits

```{r, message=FALSE, warning=FALSE}

# Create the spline summary table with coefficients, degree,
# knot placements, rgb values, and goodness-of-fit metrics.
# data frame just extracts data from the species list data from 
# each of the respective spline results
spline_table <- data.frame(
  
  Species = names(spline_results),

  Reflectance_Spline_Coefficients = sapply(spline_results, function(x) paste(x$reflectance_coef, collapse = ", ")),
  Log_Reflectance_Spline_Coefficients = sapply(spline_results_log, function(x) paste(x$log_reflectance_coef, collapse = ", ")),
  
  Reflectance_AIC = sapply(spline_results, function(x) round(x$reflectance_AIC, 2)),
  Log_Reflectance_AIC = sapply(spline_results_log, function(x) round(x$log_reflectance_AIC, 2)),  

  Reflectance_BIC = sapply(spline_results, function(x) round(x$reflectance_BIC, 2)),
  Log_Reflectance_BIC = sapply(spline_results_log, function(x) round(x$log_reflectance_BIC, 2)),

   Reflectance_logLik = sapply(spline_results, function(x) round(x$reflectance_logLik, 2)),
  Log_Reflectance_logLik = sapply(spline_results_log, function(x) round(x$log_reflectance_logLik, 2)),

  Degree_Reflectance = sapply(spline_results, function(x) c(x$degree)),
  Degree_Log_Reflectance = sapply(spline_results_log, function(x) c(x$degree)),
  
  RGB_Color = sapply(spline_results, function(x) c(x$reflectance_rgb))
  )


# Adding Internal Knots to the spline_table but I perform this outside of 
# the data frame function as there are some complications with inserting those
# values through the methodology we see below. This method, although an additional
# step, circumvents the necessity of adding each indiviual knot (for each species)
# as an individual column in the data frame

# Extracts the internal and boundary knot placements for each species 
# as a matrix for the splines using reflectance data
Internal_Knots = sapply(spline_results, function(x) round(c(x$internal_knots), 3))
Internal_Knots_log = sapply(spline_results_log, function(x) round(c(x$internal_knots), 3))

Boundary_Knots = sapply(spline_results, function(x) round(c(x$boundary_knots),3))
Boundary_Knots_log = sapply(spline_results_log, function(x) round(c(x$boundary_knots), 3))

# We must transpose the matrix to make the species names align along the rows
# to easily bind this matrix to the spline_table
Internal_Knots <- t(Internal_Knots)
Internal_Knots_log <- t(Internal_Knots_log)

Boundary_Knots <- t(Boundary_Knots)
Boundary_Knots_log <- t(Boundary_Knots_log)

# Attaching each matrix to each our spline_table
spline_table <- cbind(spline_table, Internal_Knots)
spline_table <- cbind(spline_table, Internal_Knots_log)
spline_table <- cbind(spline_table, Boundary_Knots)
spline_table <- cbind(spline_table, Boundary_Knots_log)


# 4 for loops to add each set of knot data into a singular column
# in our spline_table data frame. Check knot vector min and max values
# to ensure your for loops do not take values from a different knot 
# dataset.

# Adds our new column
spline_table$Internal_Knots <- NA

# For loop to turn knots into a long character string
# and inputs it into our newly generated column for
# each species
for (i in 1:51){
  x <- c(spline_table[i,13:47])
  x <- as.numeric(x)
  spline_table[i,87] <- toString(x)
}


spline_table$Internal_Knots_log <- NA
for (i in 1:51){
  x <- c(spline_table[i,48:82])
  x <- as.numeric(x)
  spline_table[i,88] <- toString(x)
}

spline_table$Boundary_Knots <- NA
for (i in 1:51){
  x <- c(spline_table[i, 83:84])
  x <- as.numeric(x)
  spline_table[i,89] <- toString(x)
}

spline_table$Boundary_Knots_log <- NA
for (i in 1:51){
  x <- c(spline_table[i, 85:86])
  x <- as.numeric(x)
  spline_table[i,90] <- toString(x)
}

# Removes all extraneous knot columns
spline_table <- spline_table[,-c(13:86)]

# Verifying Knot Placements

# Only a single value should be printed if the internal knots are
# placed at the same points
unique(spline_table$Internal_Knots)
unique(spline_table$Internal_Knots_log)

# Making sure internal knot placements are identical between 
# reflectance and log reflectance data
unique(spline_table$Internal_Knots) == unique(spline_table$Internal_Knots_log)

# Only a single value should be printed if the boundary knots are
# placed at the same points
unique(spline_table$Boundary_Knots)
unique(spline_table$Boundary_Knots_log)

# Making sure boundary knot placements are identical between 
# reflectance and log reflectance data
unique(spline_table$Boundary_Knots) == unique(spline_table$Boundary_Knots_log)

# Verifying Degree of our Cubic Splines

# Only a single value should be printed if the is uniform
# This value should be 3, given we are using cubic splines
unique(spline_table$Degree_Reflectance)
unique(spline_table$Degree_Log_Reflectance)

# Making sure the degree of the splines are identical between 
# reflectance and log reflectance data
unique(spline_table$Degree_Reflectance) == unique(spline_table$Degree_Log_Reflectance)

# Remove row names
rownames(spline_table) <- NULL

# Display the table in the document without row names
kable(spline_table, caption = "Summary of Spline Fits for Each Species (Including Goodness-of-Fit)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

# Save the table as a CSV
write.csv(spline_table, "spline_summary_table.csv", row.names = FALSE)

# Fixing the PDF export by increasing the margins and adjusting the layout
pdf("spline_summary_table.pdf", width = 11, height = 8.5)
gridExtra::grid.table(spline_table, rows = NULL)
dev.off()

```


### Step 7: Model scores table for reflectance and log reflectance splines

Here, we want to create a separate data frame in order to easily compare the model scores for the spline fits to each set of data (reflectance versus log-transformed reflectance values). This data frame will contain the AIC, BIC, and logLik scores that we obtained from our gls function and then we identify which model has the "better" score, and therefore which dataset we should use for our parameter estimation and ancestral state reconstruction.

```{r}


# Creates a separate data frame only containing the species names and the model scores produced from our gls
spline_model_scores <- spline_table[,c(1,4:9)]

# Adds a column to the end of the data frame capturing the minimum AIC score between the two fits (lowest AIC score is the model you should select)
spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(AIC_Preferred_Model_Score = min(c(Reflectance_AIC, Log_Reflectance_AIC)))

# Here we create a for loop system to identify and name which dataset used is preferred without having to manually check for each species.

# Placeholder vector to store which dataset is preferred to then be bound to the end of the model scoring data frame
preferred_model_name <- rep(NA, length(spline_model_scores$Species))

# for loop to determine which value (for each species) from our newly generated column matches to which dataset and store the output into the placeholder vector 
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,8] == spline_model_scores[i,2]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,8] == spline_model_scores[i,3]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,8] == spline_model_scores[i,2] & spline_model_scores[i,3] == spline_model_scores[i,8]){
    preferred_model_name[i] <- "Either"
  }
    }

# Attaches the placeholder vector to the model scores data frame
spline_model_scores <- cbind(spline_model_scores, preferred_model_name)

# Takes the column names of the data frame and stores them in a vector
column_names <- colnames(spline_model_scores)

# Adds a new value to name our newly attached column
column_names[9] <- "AIC_Preferred_Model_Name"

# Applies our column names vector as the names for our data frame
colnames(spline_model_scores) <- column_names



# We recreate an identical process for BIC scores

spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(BIC_Preferred_Model_Score = min(c(Reflectance_BIC, Log_Reflectance_BIC)))

preferred_model_name <- rep(NA, length(spline_model_scores$Species))
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,10] == spline_model_scores[i,4]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,10] == spline_model_scores[i,5]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,10] == spline_model_scores[i,4] & spline_model_scores[i,5] == spline_model_scores[i,10]){
    preferred_model_name[i] <- "Either"
  }
    }

spline_model_scores <- cbind(spline_model_scores, preferred_model_name)
column_names <- colnames(spline_model_scores)
column_names[11] <- "BIC_Preferred_Model_Name"
colnames(spline_model_scores) <- column_names



# We create an almost identical process for logLik scores. The only change is that instead of looking for the minimum logLik score, we are looking for the maximum logLik score.

spline_model_scores <- spline_model_scores %>% 
  group_by(Species) %>%
  mutate(logLik_Preferred_Model_Score = max(c(Reflectance_logLik, Log_Reflectance_logLik)))

preferred_model_name <- rep(NA, length(spline_model_scores$Species))
for (i in 1:length(spline_model_scores$Species)){
  if (spline_model_scores[i,12] == spline_model_scores[i,6]){
    preferred_model_name[i] <- "Reflectance"
  }
  else if (spline_model_scores[i,12] == spline_model_scores[i,7]){
    preferred_model_name[i] <- "Log Reflectance"
  }
  else if (spline_model_scores[i,12] == spline_model_scores[i,6] & spline_model_scores[i,7] == spline_model_scores[i,12]){
    preferred_model_name[i] <- "Either"
  }
    }

spline_model_scores <- cbind(spline_model_scores, preferred_model_name)
column_names <- colnames(spline_model_scores)
column_names[13] <- "logLik_Preferred_Model_Name"
colnames(spline_model_scores) <- column_names

spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 0] <- "Reflectance"
spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 1] <- "Log Reflectance"
spline_model_scores$logLik_Preferred_Model_Name[spline_model_scores$logLik_Preferred_Model_Name == 2] <- "Either"

# Reorders the data frame to put all of the model scores together
spline_model_scores <- spline_model_scores[,c(1,2,3,8,9,4,5,10,11,6,7,12,13)]

# Verifies if the data frame has been completed correctly
head(spline_model_scores)
```

# Step 8: Plotting model scores between datasets

Here, we want to plot the model scores from each of the datasets to each other. If our spline fits are identical, our model scores should fit along the line $y=x$. For an inconclusive determination, we would see an even split around the line if there is not a strong preference present. Otherwise, we should expect to a vast majority of data points lying on one side of the line over the other.

```{r}


# Create a vector of the color codes for each species to use in ggplot2 scatterplots
tanager_subset_colors <- c(spline_table[, "RGB_Color"])

# Puts the species name for each color as the names for the vector
names(tanager_subset_colors) <- spline_table$Species

# Character vector to be used as the title for our scatterplot legend (there could be other methods of doing this, but this was the one that I could figure out how to use with ggplot2)
title_for_legend <- "Species"


# AIC scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(intercept = 0, slope = 1)
+ xlab("Reflectance AIC Score")
+ ylab("Log Reflectance AIC Score")
+ ggtitle("AIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_AIC, y = Log_Reflectance_AIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance AIC Score")
+ ylab("Log Reflectance AIC Score")
+ ggtitle("AIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)



# BIC scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC))
+ geom_point(aes(color = names(tanager_subset_colors))) 
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(intercept = 0, slope = 1)
+ xlab("Reflectance BIC Score")
+ ylab("Log Reflectance BIC Score")
+ ggtitle("BIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_BIC, y = Log_Reflectance_BIC))
+ geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance BIC Score")
+ ylab("Log Reflectance BIC Score")
+ ggtitle("BIC Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend,values = as.character(tanager_subset_colors))
)


# logLik scores

# Scatterplot showing data spaced around the origin with y=x line present
(ggplot(data = spline_model_scores, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ xlab("Reflectance logLik Score") 
+ ylab("Log Reflectance logLik Score")
+ ggtitle("logLik Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
)

# Scatterplot centered around the data
(ggplot(data = spline_model_scores, aes(x = Reflectance_logLik, y = Log_Reflectance_logLik)) + geom_point(aes(color = names(tanager_subset_colors)))
+ theme(legend.key.size = unit(0.5, "cm"))
+ geom_hline(yintercept = 0)
+ geom_vline(xintercept = 0)
+ geom_abline(slope = 1, intercept = 0)
+ xlab("Reflectance logLik Score")
+ ylab("Log Reflectance logLik Score")
+ ggtitle("logLik Scores", subtitle = "Log Reflectance vs. Reflectance Spline Fits")
+ scale_color_manual(title_for_legend, values = as.character(tanager_subset_colors))
)



```


#Step 9: Summary statistics for 10nm wavelength bins from 300 to 700 nm

```{r, warning=FALSE}

# Creates a data frame without a column for the wavelengths
tanData_filtered_wowl <- data.frame(tanData_filtered[-1])
# Transpose the data frame to put the species names as the rows
tanData_filtered_wowl <- t(tanData_filtered_wowl)

# Create a counting vector for our for loop below
wl_bins <- seq(1, 400, 10)

# Creates a wavelength vector to match our counting vector to what our binned wavelengths would be
wavelengths <- 300:700

# 3 blank vectors to add summary statistics to. Each respectively will contain the mean, variance, and standard deviation for each 10nm wavelength bin
wl_mean <- rep(NA, 40)
wl_var <- rep(NA, 40)
wl_sd <- rep(NA, 40)

# One vector to store the raw data and a blank data frame to store all of the reflectance values for each wavelength bin
wl_data <- NULL
wl_dataframe <- NA

# for loop to extract the mean, var, and sd from each wavelength bin by using a sequence of columns and performing a summary function on that group of data. Each value is stored in its respective vector and the data is stored within our data frame. For the final bin of data, which has length 11 rather than 10, we do not attach it to our data frame, and leave it stored in our wl_data vector.
for (i in 1:40){
  # Creates our 10nm bins up until 690 nm
  sequence <- seq(wl_bins[i],(wl_bins[i])+9, 1)
  
  # Verifies that our vector is working and can match it to our wavelength bins for future clarification
  print(sequence)
  print(wavelengths[sequence])

  # Summary stats are stored in their respective locations
  wl_mean[i] <- mean(tanData_filtered_wowl[,sequence])
  wl_var[i] <- var(tanData_filtered_wowl[,sequence])
  wl_sd[i] <- sd(tanData_filtered_wowl[,sequence])
  
  # Takes the reflectance values from our data frame and stores them in a vector
  wl_data <- c(tanData_filtered_wowl[,sequence])

  # Takes our vector and stores them within a data frame for future use
  wl_dataframe <- rbind(wl_dataframe, wl_data)
  
  # Need to add this condition due to unequal wavelength bin sizes
  if (i == 40){
    sequence <- 390:400
    print(sequence)
  
    wl_mean[i] <- mean(tanData_filtered_wowl[,sequence])
    wl_var[i] <- var(tanData_filtered_wowl[,sequence])
    wl_sd[i] <- sd(tanData_filtered_wowl[,sequence])
    
    wl_data <- c(tanData_filtered_wowl[,sequence])
  }
  
  # Verifies that the length of each bin is 10 nm intervals except for our final interval, which should be 11 nm
  print(length(wl_data))
  
  # Verifying that for loop worked by comparing the values of our summary stats from our extractions match to the initial dataset. If so, all values should return TRUE.
  test_mean <- (c(tanData_filtered_wowl[,sequence]))
  print(mean(test_mean) == wl_mean[i])
}

# Combines all of our summary stat vectors into a matrix
wl_summary_stats <- cbind(wl_mean, wl_var)
wl_summary_stats <- cbind(wl_summary_stats, wl_sd)

# Wavelength bin vector
binned_wl <- c("300-309","310-319","320-329","330-339","340-349","350-359", "360-369","370-379","380-389","390-399","400-409","410-419","420-429","430-439","440-449","450-459","460-469","470-479","480-489","490-499","500-509","510-519","520-529","530-539", "540-549","550-559","560-569","570-579","580-589","590-599","600-609","610-619","620-629","630-639","640-649","650-659","660-669","670-679","680-689","690-700")

# Applies our wavelength bins as names for our summary stat matrix
rownames(wl_summary_stats) <- binned_wl

# Turns our summary stat matrix into a data frame
wl_summary_stats <- data.frame(wl_summary_stats)

# Verifying that our data frame looks as it should
head(wl_summary_stats)


# Transposes matrix to place wavelength bins as columns
wl_dataframe <- t(wl_dataframe)

# Removes both the NA column and the last column (690-700 nm) as this column has omitted data due to column length coercion (561 data points -> reduced to 510 data points)
wl_dataframe <- wl_dataframe[,2:40]

# Takes our dataframe and turns it into a singular vector, and adds our data points from 690-700 nm. We do this to use the boxplot function seamlessly.
wl_dataframe <- c(wl_dataframe, wl_data)


# Blank vector to store our wavelength bins to identify which values in wl_dataframe come from which wavelength bin
wl_ranges <- NULL

# for loop to create a long character vector listing each wavelength bin equal to number of data points from each wavelength bin
for (i in 1:40){
  if (i <= 39){
  
  x <- rep(binned_wl[i], 510)
  
  wl_ranges <- cbind(wl_ranges, x)
  
  }
  
    if (i == 40){
    
    x <- rep(binned_wl[i], 561)
    wl_ranges <- c(wl_ranges, x)
      
    }
}

# Binds our reflectance data to each wavelength bin into a matrix
wl_dataframe <- cbind(wl_dataframe, wl_ranges)

# Verifies matrix was formed correctly
head(wl_dataframe)

# Adds names to our matrix
colnames(wl_dataframe) <- c("Reflectance_Values", "Wavelength_Bins")

# Converts our matrix into a data frame
wl_dataframe <- data.frame(wl_dataframe)

# Checks that our reflectance values are numerical values and that our wavelength bins are character values
str(wl_dataframe)

# Converts our Reflectance_Values column into numerical values to use for our boxplot
wl_dataframe$Reflectance_Values <- as.numeric(wl_dataframe$Reflectance_Values)

# Verifies if our Reflectance_Values column is now numerical values
str(wl_dataframe)

# Sequence vector with the midpoints of our wavelength bins
sequence <- seq(305, 695, 10)

# Blank vectors to store RGB codes into
color_for_plots_V1 <- NULL
color_for_plots_V2 <- NULL
color_for_plots_V3 <- NULL
color_for_plots_V4 <- NULL

# for loop to generate different color options for the boxplots. Here we parameterize different Gaussian curves of spectra at the midpoint of each wavelength interval with varying widths and heights of our curves.
for (i in 1:length(sequence)){
  
  color_for_plots_V1[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i]))
  
  color_for_plots_V2[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], width_gauss = 10))
  
  color_for_plots_V3[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], width_gauss = 10, ylim = c(0, wl_summary_stats[i,1])))
  
  color_for_plots_V4[i] <- spec2rgb(simulate_spec(wl_peak = sequence[i], ylim = c(0, wl_summary_stats[i,1])))
}


# Boxplots of the reflectance data for each wavelength bin with different color options

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V1, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V2, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V3, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

boxplot(data = wl_dataframe, Reflectance_Values~Wavelength_Bins, col = color_for_plots_V4, main = "Summary Statistics for Thraupidae Crown Reflectance (51 Species)", xlab = "Wavelength Bins (10nm Intervals)", ylab = "Reflectance (%)")

```


### Step 10: Spline Coefficient Extraction for BEAST

```{r}


# Empty matrix for the spline coefficients
spline_coef_data <- NA

# for loop to extract spline coefficients for each species from our spline_results (list)
for (species_name in names(spline_results)){
  
  name_vector <- as.character(species_name)
  
  spline_coefficients <- spline_results[[name_vector]]
  
  spline_coefficients <- spline_coefficients$reflectance_coef
  
  spline_coef_data <- rbind(spline_coef_data, spline_coefficients)
  
  
}

# Removes NA row
spline_coef_data <- spline_coef_data[-1,]

# Turns our matrix into a data frame
spline_coef_data <- data.frame(spline_coef_data)

# Adds species labels to each row of spline coefficients
rownames(spline_coef_data) <- names(spline_results)

# Explicit species name vector to add to our data frame
species <- as.character(names(spline_results))

# Adds a species name vector to our data frame. This is needed for BEAST to know what spline coefficients are for each species
spline_coef_data <- cbind(species, spline_coef_data)

# Vector containing the names of the species column and each spline coefficient extracted
coefficient_names <- c("Species", "Intercept", "Coefficient.1","Coefficient.2","Coefficient.3","Coefficient.4","Coefficient.5","Coefficient.6","Coefficient.7","Coefficient.8","Coefficient.9","Coefficient.10","Coefficient.11","Coefficient.12","Coefficient.13","Coefficient.14","Coefficient.15","Coefficient.16","Coefficient.17","Coefficient.18","Coefficient.19","Coefficient.20","Coefficient.21","Coefficient.22","Coefficient.23","Coefficient.24","Coefficient.25","Coefficient.26","Coefficient.27","Coefficient.28","Coefficient.29","Coefficient.30","Coefficient.31","Coefficient.32","Coefficient.33","Coefficient.34","Coefficient.35","Coefficient.36","Coefficient.37","Coefficient.38")

# Applies our coefficient name vector to our data frame
colnames(spline_coef_data) <- coefficient_names

# Verifies our data is in a data frame
str(spline_coef_data)

# Writes a text file of our data frame to use for BEAST
write_tsv(spline_coef_data, file = "spline_coefficients_BEAST.txt")



```



# Step 11: OUTLINING BEAST AND TRACER PROCESS

# Step 12: Analyzing diffusion rates of spline coefficients

```{r}

# Loads in the .txt file containing our diffusion rate data for our spline coefficients
coefficient_diffusion_rates <- read.delim("diffusion_rate_data.txt")

# Manually written vector to contain an ordered list of the spline coefficients
coefficient_diffusion_rates_names <- c("Intercept.diffusionRate", "Coefficient.1.diffusionRate","Coefficient.2.diffusionRate","Coefficient.3.diffusionRate","Coefficient.4.diffusionRate","Coefficient.5.diffusionRate","Coefficient.6.diffusionRate","Coefficient.7.diffusionRate","Coefficient.8.diffusionRate","Coefficient.9.diffusionRate","Coefficient.10.diffusionRate","Coefficient.11.diffusionRate","Coefficient.12.diffusionRate","Coefficient.13.diffusionRate","Coefficient.14.diffusionRate","Coefficient.15.diffusionRate","Coefficient.16.diffusionRate","Coefficient.17.diffusionRate","Coefficient.18.diffusionRate","Coefficient.19.diffusionRate","Coefficient.20.diffusionRate","Coefficient.21.diffusionRate","Coefficient.22.diffusionRate","Coefficient.23.diffusionRate","Coefficient.24.diffusionRate","Coefficient.25.diffusionRate","Coefficient.26.diffusionRate","Coefficient.27.diffusionRate","Coefficient.28.diffusionRate","Coefficient.29.diffusionRate","Coefficient.30.diffusionRate","Coefficient.31.diffusionRate","Coefficient.32.diffusionRate","Coefficient.33.diffusionRate","Coefficient.34.diffusionRate","Coefficient.35.diffusionRate","Coefficient.36.diffusionRate","Coefficient.37.diffusionRate","Coefficient.38.diffusionRate")

# Blank vector to store the order of the columns in relation to the order of our spline coefficient names vector
diffusion_rate_column_order <- NULL

# for loop to figure out the location of each column to to put it in sequential order (Intercept, 1, 2, ..., 38). This step is necessary as the columns are not in this sequential order when extracted from BEAST.
for (i in 1:length(coefficient_diffusion_rates_names)){
  diffusion_rate_column_order[i] <- which(coefficient_diffusion_rates_names[i] == colnames(coefficient_diffusion_rates))
    print(which(coefficient_diffusion_rates_names[i] == colnames(coefficient_diffusion_rates)))
}

# Reorders the columns of our data frame to match the sequential order that we would like
coefficient_diffusion_rates <- coefficient_diffusion_rates[,c(1,diffusion_rate_column_order)]

# Verifies that we have the correct order that we are looking for
head(coefficient_diffusion_rates)

# Transposes the data frame to make the coefficients the rows
coefficient_diffusion_rates <- t(coefficient_diffusion_rates)

# When transposing the data frame, our data frame became a matrix, and here we convert it back into a data frame
coefficient_diffusion_rates <- data.frame(coefficient_diffusion_rates)

# Turns the column names with the values in the first row
colnames(coefficient_diffusion_rates) <- coefficient_diffusion_rates[1,]

# We remove the first row as they are now the column names for our data frame
coefficient_diffusion_rates <- coefficient_diffusion_rates[-1,]

# Verifies the structure of our object. We can see that all numerical values had been coerced into character vectors
str(coefficient_diffusion_rates)

# for loop to convert all columns into numerical values rather than character values (with the exception of the 95% HPD interval and value range columns as there are not singular values and do not work the as.numeric function)
for (i in c(1:5,7,9:11)){
coefficient_diffusion_rates[,i] <- as.numeric(coefficient_diffusion_rates[,i])
}

# Verifies that the columns that we converted are now numeric in nature
str(coefficient_diffusion_rates)

# Scatterplot showing the mean diffusion rate values for our spline coefficients, showing error bars equivalent to +/- 1 standard deviation
(ggplot(coefficient_diffusion_rates, aes(x = 0:38, y = mean))
+ geom_errorbar(aes(ymax = mean+stdev, ymin = mean-stdev), color = "orangered")
+ geom_point(color = "royalblue")
+ ggtitle("Diffusion Rates for Spline Coefficients", subtitle = "0 = Intercept Coefficient")
+ xlab("Spline Coefficients")
+ ylab("Diffusion Rate")
)


```

# Step 13: Reconstucting splines (methods)

One of the main points of reconstructing splines is that we need to do it without the predictive power of a generalized least squares model, which is how we did it in Step 5. This is due to the fact that when we allow our coefficients to diffuse in BEAST for an ancestral state reconstruction (ASR), the only things that we have to reconstruct our diffused splines will just be diffused coefficients and the basis that we are working with (300-700 nm). Below, I will use a case study, using TanCyo (Tangara cyanotis) to show how we can construct splines for a species without the need for a least squares model.



#### Spline Reconstruction from gls function
```{r}

# Extracting all of the data from our fit_splines function into a new object (named after our focal species)
TanCyo <- spline_results[["TanCyo"]]

# Here we plot a scatterplot using the predicted points from our gls model for this species
plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "TanCyo gls Spline Reconstruction")



# Side-by-side plot comparison of our gls reconstructed plot and the plot from Step 5 (using the actual reflectance data)

par(mfrow=c(1,2), mar = c(5.1,4.1,4.1,1.1))

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 0.6)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

plot(tanData_filtered$wl, tanData_filtered$TanCyo, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", "TanCyo"),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(tanData_filtered$wl, predict(spline_results[["TanCyo"]]$reflectance_spline_fit), col = rgb_colors[["TanCyo"]], lwd = 2)
mtext(paste("AIC:", round(spline_results[["TanCyo"]]$reflectance_AIC, 3), "BIC:", round(spline_results[["TanCyo"]]$reflectance_BIC, 2), "logLik:", round(spline_results[["TanCyo"]]$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))



```

#### Spline Reconstruction with only spline coefficients and a basis

I could not find an intuitive way to do this through just base R, but by using the package splines2, I am able to reconstruct the splines with just this information available.

```{r}

# Creating a basis matrix using the function bSpline from the splines2 package. We use the same wavelength range and maintain the same degrees of freedom (35 knots)
bspline_matrix_bSpline <- bSpline(tanData_filtered$wl, df = 38)

# Verifying that the bSpline and bs functions produce identical basis matrices (output should be TRUE)
identical(data.frame(bs(tanData_filtered$wl, df = 38)), data.frame(bSpline(tanData_filtered$wl, df = 38)))

# Extract the coefficients available to us from our gls model fit into its own vector
TanCyo_spline_coefficients <- TanCyo$reflectance_coef

# Must make coefficients from 2:39 as bSpline function does not create an intercept coefficient in its output, and therefore cannot use it in reconstructions
coef_spline_reconstruction <- cbind(300:700, predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Adds names to the columns of the matrix
colnames(coef_spline_reconstruction) <- c("wl", "reflectance")

# Turns the matrix into a data frame
coef_spline_reconstruction <- data.frame(coef_spline_reconstruction)

# Code to show why we need to use the splines2 package
# Basis matrix produced by the function bs
bspline_matrix_bs <- bs(tanData_filtered$wl, df = 38)

# Object that would be created using the bs produced matrix. The output is another matrix
str(predict(bspline_matrix_bs, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Object that would be created using the bSpline produced matrix. The output is a one column matrix (or a vector)
str(predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))

# Plotting the spline reconstruction using our matrix/coef method
plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "TanCyo Coefficient Spline Reconstruction", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))


# Side-by-side plots of the gls reconstruction and matrix/coef reconstruction
par(mfrow=c(1,2), mar = c(5.1,4.1,4.1,1.1))

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 1)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)


plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))
```

From the plots above, we can see two key differences from our initial plot. The first is that the color between the plots. The gls plot has an RGB color of `r TanCyo$reflectance_rgb`, while the coefficient method has a color of `r spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero"))`. The next major difference (and directly impacts why there is a color change), is that the reflectance scales are completely different from another, with all values on the left plot being greater than 0, while the data points on the right plot do not follow that trend. So if using a basis and spline coefficients to rebuild a curve, will we lose all of the biological information, where we only retain the shape of the curve? No. Earlier in our reconstruction, we mentioned that we had to omit the intercept coefficient due to `predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39])))` not being able to use it. But the intercept coefficient is important in dictating where to place the spline along the y-axis, thus all we have to do to our data is to add the spline coefficient value to all of our data points.

```{r message = FALSE}

# Prints TanCyo intercept coefficient
TanCyo$reflectance_coef[1]

# Plots the reconstructed splines from the matrix/coef method but adds the intercept values to the reconstructed reflectance values
plot(x = 300:700, y = coef_spline_reconstruction$reflectance + TanCyo$reflectance_coef[1], pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

# Copies our coef_spline_reconstruction data frame
coef_spline_reconstruction_plusintercept <- coef_spline_reconstruction

# Adds the intercept coefficient value to all of the reflectance values
coef_spline_reconstruction_plusintercept$reflectance <- coef_spline_reconstruction_plusintercept$reflectance + TanCyo$reflectance_coef[1]

# Side-by-side plots of the initial data, gls reconstruction, matrix/coef reconstruction, modified matrix/coef reconstruction
par(mfrow=c(2,2), mar = c(5.1,4.1,4.1,1.1))

plot(tanData_filtered$wl, tanData_filtered$TanCyo, type = "p", pch = 16, cex = 0.5,  # Adjusted size of points
     col = adjustcolor("black", alpha.f = 0.5),  # Adjusted transparency of points
     main = paste("Cubic Splines (Refl.) -", "TanCyo"),
     xlab = "Wavelength (nm)", ylab = "Reflectance (%)")
lines(tanData_filtered$wl, predict(spline_results[["TanCyo"]]$reflectance_spline_fit), col = rgb_colors[["TanCyo"]], lwd = 2)
mtext(paste("AIC:", round(spline_results[["TanCyo"]]$reflectance_AIC, 3), "BIC:", round(spline_results[["TanCyo"]]$reflectance_BIC, 2), "logLik:", round(spline_results[["TanCyo"]]$reflectance_logLik)),
      side = 3, line = 0.5, cex = 0.8, col = "blue")

plot(x = 300:700, y = predict(TanCyo$reflectance_spline_fit), col = TanCyo$reflectance_rgb, pch = 19, xlab = "Wavelength (nm)", ylab = " Reflectance (%)", main = "gls Spline Reconstruction", cex = 0.6)
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)


plot(x = 300:700, y = coef_spline_reconstruction$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", cex = 0.6, col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

plot(x = 300:700, y = coef_spline_reconstruction_plusintercept$reflectance, pch = 19, main = "Coefficient Spline Reconst.", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", cex = 0.6, col = spec2rgb(procspec(as.rspec(coef_spline_reconstruction_plusintercept), fixneg = "zero")))
mtext("TanCyo", col = "blue", side = 3, line = 0.5, cex = 0.8)

par(mfrow=c(1,1), mar = c(5.1,4.1,4.1,2.1))


# Verification that our final spline reconstruction produces an identical color to the initial reflectance data and the gls reconstruction method

# Plot 1
rgb_colors[["TanCyo"]]
# Plot 2
TanCyo$reflectance_rgb
# Plot 3
spec2rgb(procspec(as.rspec(coef_spline_reconstruction), fixneg = "zero"))
# Plot 4
spec2rgb(procspec(as.rspec(coef_spline_reconstruction_plusintercept), fixneg = "zero"))

```
Thus, we have shown we have accurately recreated the spline from our gls model and can produce identical colors to that of the original data just from the spline coefficients for a species and by using a basis for the trait data.


### Step 14: What do the coefficients mean?

In the last step, we were able to reconstruct what the splines were through the use of a basis (wavelengths from 300-700 nm) and spline coefficients. We were able to deduce that the intercept was the key component to maintaining the biological meaning to our splines if ran through BEAST. Here we attempt to identify the function of the different spline coefficients through the case study of TanCyo. 

```{r}

# Taking our matrix created from bSpline and turning it into a matrix object
basis_spline_matrix <- matrix(bspline_matrix_bSpline, nrow = 401, ncol = 38)

# Turning our TanCyo reflectance coefficients into a 38x1 matrix
spline_coefficient_matrix <- matrix(TanCyo$reflectance_coef[2:39])

# Multiplying the matrices using the matrix multiplication operator (%*%)
spline_reconstruction <- basis_spline_matrix %*% spline_coefficient_matrix

# Verification that this matrix multiplication is how we are getting our curves through the spline functions (does not include the addition of the intercept coefficient here although if the answer is TRUE, adding the intercept to both objects will still produce a TRUE output)
identical(c(spline_reconstruction), coef_spline_reconstruction$reflectance)



```
IT'S JUST MATRIX MULTIPLICATION, I HAVE NO IDEA WHAT THE BIOLOGICAL INTERPRETATION OF THE COEFFICIENTS ARE BUT I DOUBT IT IS USEFUL TO TRY AND UNDERSTAND THEM OR TAKE MEANS OF THEM ETC. 
The real question at this stage is to identify what the basis matrix represents for our system, as it is not clear as to what it could represent. Are the spline coefficients just a scalar to shape the curve?




### Step 15: What do spline coefficients do? What does the basis matrix mean?
```{r}




TanCyo_spline_reconstruction <- cbind(300:700,predict(bspline_matrix_bSpline, coef = as.numeric(c(TanCyo_spline_coefficients[2:39]))))


plot(300:700, TanCyo_spline_reconstruction[,2])

TanCyo_adjusted_coefficients <- TanCyo_spline_coefficients[2:39]
print(TanCyo_spline_coefficients[21])
TanCyo_adjusted_coefficients[20] <- TanCyo_adjusted_coefficients[20]+1

TanCyo_adjusted_coefficients <- cbind(300:700, predict(bspline_matrix_bSpline, coef = TanCyo_adjusted_coefficients))
plot(300:700, TanCyo_adjusted_coefficients[,2])


par(mfrow=c(1,2))
plot(300:700, TanCyo_spline_reconstruction[,2], pch = 19, main = "TanCyo Base Coef.")
plot(300:700, TanCyo_adjusted_coefficients[,2], pch = 19, main = "TanCyo Adjusted Coef.")
par(mfrow=c(1,1))

spline_coef_comparison <- cbind(predict(bspline_matrix_bSpline, coef = (c(TanCyo_spline_coefficients[2:39]))), c(TanCyo_adjusted_coefficients[,2]))
spline_coef_comparison <- cbind(300:700, spline_coef_comparison)

```
I do not think the basis matrix or the spline coefficients have any inherit biological information.

### Step 16: Comparing our splines for mean reflectance data and mean spline coefficients

```{r}

mean_reflectance_values <- NULL
for (i in 1:401){

  x <- i
  mean_reflectance_values[i] <- mean(tanData_filtered_wowl[,x])

}

random_number <- round(runif(1, min = 1, max = 401), 0)
mean_reflectance_values[random_number] == mean(tanData_filtered_wowl[,random_number])

mean_reflectance_values <- cbind(300:700, mean_reflectance_values)

spline_fit_mean_reflectance <- gls(mean_reflectance_values[,2] ~ bs(mean_reflectance_values[,1], df = 38), correlation = corAR1(form = ~1))

mean_reflectance_values <- cbind(mean_reflectance_values, predict(spline_fit_mean_reflectance)) 

colnames(mean_reflectance_values) <- c("wl", "reflectance", "spline_fit")

plot(x = 300:700, y = mean_reflectance_values[,"reflectance"], xlab = "Wavelength (nm)", ylab = "Reflectance (%)", main = "Mean Reflectance Values", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_reflectance_values[,"spline_fit"], col = spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero")), lwd = 3)

mean_spline_coefficients <- NULL
for (i in 1:39){
  
  x <- i+1
  
  mean_spline_coefficients[i] <- mean(spline_coef_data[,x])
  
}

random_number <- round(runif(1, min = 1, max = 39), 0)
mean_spline_coefficients[random_number] == mean(spline_coef_data[,random_number+1])

mean_spline_coefficients_output <- cbind(300:700, predict(bspline_matrix_bSpline, coef = mean_spline_coefficients[2:39]))

colnames(mean_spline_coefficients_output) <- c("wl", "reflectance")

mean_spline_coefficients_output[,2] <- mean_spline_coefficients_output[,2] + mean_spline_coefficients[1]

plot(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], main = "Mean Spline Coefficients", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], col = spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero")), lwd = 3)

spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero"))
spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero"))

par(mfrow=c(1,2))

plot(x = 300:700, y = mean_reflectance_values[,"reflectance"], xlab = "Wavelength (nm)", ylab = "Reflectance (%)", main = "Mean Reflectance Values", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_reflectance_values[,"spline_fit"], col = spec2rgb(procspec(as.rspec(mean_reflectance_values), fixneg = "zero")), lwd = 3)

plot(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], main = "Mean Spline Coefficients", xlab = "Wavelength (nm)", ylab = "Reflectance (%)", pch = 19, cex = 0.75)
lines(x = 300:700, y = mean_spline_coefficients_output[,"reflectance"], col = spec2rgb(procspec(as.rspec(mean_spline_coefficients_output), fixneg = "zero")), lwd = 3)

par(mfrow=c(1,1))

```