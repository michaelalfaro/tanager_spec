---
title: "Tanager Evolution Project Notes"
output: html_document
date: "2024-08-13"
---


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(pbapply)
library(pavo)
library(DescTools)
library(geiger)
library(stringr)
library(scales)
library(ggtree)
library(splines)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(nlme)
library(splines2)
```


### initialization

```{r}


suppressMessages({
  # File pathway linking to the reflectance data for Thraupidae specimens on laptop
#  ddPath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\RefDataSpeciesSummary_MatchingMF\\data"
  
  # File pathway linking to the reflectance data for Thraupidae specimens on PC
  ddPath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\RefDataSpeciesSummary_MatchingMF"

  # Reads in all of .csv files
  dat <- pblapply(list.files(ddPath, full=T), read.csv)
  # Extracts all of the wavelengths and turns it into a vector
  wl <- dat[[1]][, 1]
  # Removes the wavelength column from each of the species' dataframes
  dat <- sapply(dat, "[", -1)
  
  # Takes the reflectance data from each patch available for each species 
  # Combines reflectance data with wavelength vector ranging from 300-700 nm
  specs <- as.rspec(cbind(wl, do.call(cbind, dat)), lim=c(300, 700))
  # Turns all negative reflectance values in dataframe to 0
  specs <- procspec(specs, fixneg="zero")
  
  # Creates a dataframe with just male specimens
  male_specs <- specs %>% select(!ends_with("f"))
  
  # Creates a dataframe from the male specimen data frame using only 
  # the crown patch of the bird
  crown_data <- male_specs %>%
    select(wl, starts_with("Crown_")) %>%
    rename_with(~ gsub("m$", "", .)) %>%
    rename_with(~ gsub("^Crown_", "", .))
  
  # Finds the rgb hex code for each of the crown patches
  rgb_colors <- spec2rgb(crown_data)
  # Adds names of the species to each hex color code
  names(rgb_colors) <- names(crown_data)[-1]
  
  # Verifies that dataframe has been created correctly
  head(crown_data)
})

```



### Step 1 Extracting tanager tree

get the tanagers only

```{r, message=FALSE, warning=FALSE}

# File pathway linking to the Thraupidae tree on laptop
#treepath <- "C:\\Users\\proto\\OneDrive\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# File pathway linking to the Thraupidae tree on PC
treepath <- "C:\\Users\\batra\\Documents\\tanager_spec\\tanager_spec\\data\\MCC_Tree_SpNames.nex"

# Reads Thraupidae tree into R
tt <- read.nexus(treepath)

# Extract the tip labels (species names) from the tree
tan_species <- grep("^Tan", tt$tip.label, value = TRUE)

# Find the MRCA node of the species that start with "Tan"
mrca_node <- getMRCA(tt, tan_species)

# Extract the subtree from the MRCA node
tanagerTree <- extract.clade(tt, mrca_node)

# Plot the tanagerTree
p <- ggtree(tanagerTree) +
  geom_tiplab(size = 2.5, align = TRUE) +
  theme_tree2()

# Display the plot
print(p)

# Creates a NEXUS tree file into working directory
write.nexus(tanagerTree, file = "tanagerTree.NEXUS")
```



### Step 2 Create a Data Frame Matching the Tanager Tree

```{r, message=FALSE, warning=FALSE}
# Extract the species names (tip labels) from the tanagerTree
tanager_species <- tanagerTree$tip.label

# Filter crown_data to include only species that are present in tanagerTree
tanData_filtered <- crown_data %>%
  select(wl, any_of(tanager_species))

# Display the filtered tanData to verify dataframe created correctly
head(tanData_filtered)

# Verifies that there are 0 species in dataframe that should not be there
(names(tanData_filtered[-1]) == tanager_species)

# Verifies that there are not any species have not been added to dataframe
length(names(tanData_filtered[-1])) == length(tanager_species)


```



### Step 3: Fitting Cubic Splines to the Tanager Reflectance and Log-Transformed Reflectance Data

```{r, message=FALSE, warning=FALSE}
### Step 3: Fitting Cubic Splines to Tanager reflectance data

 # Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines <- function(wl, reflectance) {
    # Fit cubic splines to base reflectance data with 38 degrees of freedom (35 knots)
    # We use gls instead of lm, as our error structure fails the independence assumption
    # corAR1 was the error structure recommended for us to use
    # When using the corAR1 function, the argument value pertains to the type of autocorrelation present in the
    # corAR1 autocorrelation structure (at any given point, we only care about the autocorrelation of the next
    # surrounding point {x, x+1}).
    # For corAR1, I leave the 'value' argument at 0, given that it does not change any of the coefficient values
    # or the model score values. I will note that the error structure performs better (+ values) 
    # and worse (- values) at non-zero values, although I am unsure if this has any noteworthy
    # benefits to optimize. I need to talk to Professor Marc Suchard to clarify if leaving
    # it at the default of zero is acceptable.
    # With the form argument, I used form = ~ 1, form = ~ 300:700, and form = ~ wl,
    # and each produced identical results, so I will stick with the default of 
    # form = ~ 1 unless told otherwise.
    # For the final argument ('fixed'), fixed = TRUE produces lower residual standard
    # error values, but the model score performs lower than when fixed = FALSE.
    # I think this another question that needs to be asked as to which is better,
    # but for now, I will keep the default as fixed = FALSE.
    cubic_spline_fit_reflectance <- gls(reflectance ~ bs(wl, df = 38), correlation = 
                                          corAR1(form = ~ 1))
    
    # Fit cubic spline to log-transformed reflectance values with 38 degrees of freedom (35 knots)
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    # It is important to note that when working with trait data, we want to 
    # use the same basis matrix to preserve the same "trait space" (need to clarify
    # if this the correct thinking) between species. Thus, we make sure to keep the
    # same range of wavelength when proceeding forward (300-700 nm).
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    reflectance_coef <- round(coef(cubic_spline_fit_reflectance), 2)
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    reflectance_AIC <- summary(cubic_spline_fit_reflectance)$AIC
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    reflectance_BIC <- summary(cubic_spline_fit_reflectance)$BIC
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC
        
    reflectance_logLik <- summary(cubic_spline_fit_reflectance)$logLik
    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                         predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    reflectance_rgb <- spec2rgb(reflectance_rspec)
  
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      reflectance_spline_fit = cubic_spline_fit_reflectance,
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      reflectance_coef = reflectance_coef,
      log_reflectance_coef = log_reflectance_coef,
      reflectance_AIC = reflectance_AIC,
      log_reflectance_AIC = log_reflectance_AIC,
      reflectance_BIC = reflectance_BIC,
      log_reflectance_BIC = log_reflectance_BIC,
      reflectance_logLik = reflectance_logLik,
      log_reflectance_logLik = log_reflectance_logLik,
      reflectance_rgb = reflectance_rgb,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }

# Function to fit a natural spline and a cubic spline, returning the models, coefficients, and goodness-of-fit metrics
  fit_splines_log <- function(wl, reflectance) {

    # Fit cubic spline to log-transformed reflectance values with 38 degrees of freedom (35 knots)
    cubic_spline_fit_log_reflectance <- gls(log(reflectance) ~ bs(wl, df = 38), correlation
                                            = corAR1(form = ~ 1))
    
    # bs function contains data that is not added to the gls model
    # This includes degree of the functions used, the placement of the
    # boundary and internal knots, and the basis matrix of the wavelengths.
    basis_spline_data <- bs(wl, df = 38)
    
    # Extract coefficients from each set of fits
    log_reflectance_coef <- round(coef(cubic_spline_fit_log_reflectance), 2)
    
    # Calculate goodness-of-fit metrics (AIC, BIC, and logLik values)
    log_reflectance_AIC <- summary(cubic_spline_fit_log_reflectance)$AIC
    
    log_reflectance_BIC <- summary(cubic_spline_fit_log_reflectance)$BIC

    log_reflectance_logLik <- summary(cubic_spline_fit_log_reflectance)$logLik

    # Extracts rspec and rgb values from the reflectance curves
    log_reflectance_rspec <- as.rspec(data.frame(wl = wl, reflectance = 
                          predict(cubic_spline_fit_reflectance)), lim = c(300, 700))
    log_reflectance_rgb <- spec2rgb(log_reflectance_rspec)
    
    # Generate a list containing all of our pulled data
    return(list(
      log_reflectance_spline_fit = cubic_spline_fit_log_reflectance,
      log_reflectance_coef = log_reflectance_coef,
      log_reflectance_AIC = log_reflectance_AIC,
      log_reflectance_BIC = log_reflectance_BIC,
      log_reflectance_logLik = log_reflectance_logLik,
      log_reflectance_rgb = log_reflectance_rgb,
      degree = attributes(basis_spline_data)$degree,
      internal_knots = attributes(basis_spline_data)$knots,
      boundary_knots = attributes(basis_spline_data)$Boundary.knots
    ))
  }
  
  
  # Here we need to make a separate dataframe for our log-transformed data
  # This is to convert any values less than 1 to 1 to avoid Inf/NaN errors during 
  # our log-transformation of the reflectance data

  # Creates a separate dataframe for only log-transformed data
  tanlogData_filtered <- tanData_filtered
  
  # Nested for loop to turn all data points < 1 into 1 to prevent any Inf/NaN errors
  for (i in 2:52){
    y <- as.numeric(i)
    for (j in 1:401){
      x <- as.numeric(j)
      matrix_position <- tanlogData_filtered[x,y]
      if (tanlogData_filtered[x,y] < 1){
        tanlogData_filtered[x,y] <- 1
      }
       else if (tanlogData_filtered[x,y] >= 1){
        tanlogData_filtered[x,y] <- matrix_position
       }
    }
}

  
  
  tanlogData_filtered <- log(tanlogData_filtered)
  tanlogData_filtered$wl <- exp(tanlogData_filtered$wl)

  # Apply the spline fitting function to each species
  spline_results <- lapply(tanData_filtered[-1], function(reflectance) {
    fit_splines(tanData_filtered$wl, reflectance)
  })

```